<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SPX102 Coach Ross</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <!-- Tailwind CSS for modern styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    :root {
      font-family: 'Open Sans', sans-serif;
      --color-primary: #0052C4;
      --color-secondary: #fce726;
      --color-surface: #ffffff;
      --color-muted: #f8fafc;
      --color-border: #e2e8f0;
      --color-text: #0f172a;
      --color-subtle: #475569;
    }
    
    /* Custom Scrollbar */
    .scrollbar-hide::-webkit-scrollbar {
        display: none;
    }
    .scrollbar-hide {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }
    
    .custom-scroll::-webkit-scrollbar {
      width: 6px;
    }
    .custom-scroll::-webkit-scrollbar-track {
      background: rgba(226, 232, 240, 0.8);
    }
    .custom-scroll::-webkit-scrollbar-thumb {
      background-color: #94a3b8;
      border-radius: 20px;
    }

    /* Message Bubbles */
    .msg-user {
      border-radius: 18px 18px 4px 18px;
    }
    .msg-bot {
      border-radius: 18px 18px 18px 4px;
    }

    .msg-user,
    .msg-bot,
    .rich-text {
      word-break: break-word;
      overflow-wrap: anywhere;
      hyphens: auto;
      max-width: 100%;
    }

    /* Bounce animation for dots */
    .typing-dot {
      animation: bounce 1.4s infinite ease-in-out both;
      background-color: #94a3b8; 
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
      margin: 0 2px;
    }
    
    .typing-dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-dot:nth-child(2) { animation-delay: -0.16s; }
    
    @keyframes bounce {
      0%, 80%, 100% { transform: scale(0); }
      40% { transform: scale(1); }
    }

    /* Gradient Text */
    .text-gradient {
      background: linear-gradient(to right, #0052C4, #1a73e8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    /* Rich text styling for bot replies */
    .rich-text {
      color: var(--color-text);
    }
    .rich-text h2,
    .rich-text h3,
    .rich-text h4 {
      font-weight: 700;
      letter-spacing: -0.01em;
      color: var(--color-primary);
      margin-bottom: 0.35rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }
    .rich-text h2::before,
    .rich-text h3::before,
    .rich-text h4::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 9999px;
      background: linear-gradient(135deg, #0052C4, #1a73e8);
      box-shadow: 0 0 0 6px rgba(0, 82, 196, 0.08);
    }
    .rich-text p {
      margin-bottom: 0.75rem;
      line-height: 1.7;
    }
    .rich-text ul {
      list-style: none;
      padding-left: 0;
      margin: 0.5rem 0 1rem;
      display: grid;
      gap: 0.35rem;
    }
    .rich-text ul li {
      position: relative;
      padding-left: 1.2rem;
    }
    .rich-text ul li::before {
      content: "•";
      position: absolute;
      left: 0;
      top: 0;
      color: var(--color-primary);
      font-weight: 700;
    }
    .rich-text ol {
      counter-reset: item;
      padding-left: 0;
      margin: 0.5rem 0 1rem;
      display: grid;
      gap: 0.35rem;
    }
    .rich-text ol li {
      counter-increment: item;
      padding-left: 1.6rem;
      position: relative;
    }
    .rich-text ol li::before {
      content: counter(item) ".";
      position: absolute;
      left: 0;
      top: 0;
      color: var(--color-primary);
      font-weight: 700;
    }
    .rich-text hr {
      border: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(148, 163, 184, 0.4), transparent);
      margin: 1.5rem 0;
    }
    .rich-text table {
      width: 100%;
      max-width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 12px;
      overflow: hidden;
      background: #f8fafc;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      display: block;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .rich-text th,
    .rich-text td {
      padding: 0.65rem 0.9rem;
      text-align: left;
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
    }
    .rich-text th {
      background: linear-gradient(90deg, rgba(0, 82, 196, 0.12), rgba(26, 115, 232, 0.08));
      color: #0f172a;
      font-weight: 700;
      letter-spacing: 0.01em;
      text-transform: uppercase;
      font-size: 0.75rem;
    }
    .rich-text tr:last-child td {
      border-bottom: none;
    }
    .rich-text strong {
      color: #0f172a;
      font-weight: 700;
    }
    .rich-text .card-block {
      background: linear-gradient(145deg, rgba(0, 82, 196, 0.06), rgba(240, 247, 255, 0.9));
      border: 1px solid rgba(0, 82, 196, 0.25);
      padding: 1rem;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0, 82, 196, 0.08);
      backdrop-filter: blur(6px);
      margin-bottom: 0.9rem;
    }

    .tts-button {
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: #475569;
      background: #f8fafc;
      transition: all 0.2s ease;
    }
    .tts-button:hover {
      color: #0052C4;
      border-color: rgba(0, 82, 196, 0.6);
      background: #eff6ff;
    }
    .tts-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .tts-button[data-state="loading"] {
      color: #0052C4;
      border-color: rgba(0, 82, 196, 0.4);
      background: rgba(219, 234, 254, 0.6);
      animation: ttsPulse 1.1s ease-in-out infinite;
    }
    .tts-button[data-state="loading"] svg {
      animation: ttsSpin 1s linear infinite;
    }
    .tts-highlight {
      background-color: var(--color-secondary);
      border-radius: 6px;
      box-decoration-break: clone;
      -webkit-box-decoration-break: clone;
    }
    @keyframes ttsPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.08); }
    }
    @keyframes ttsSpin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .bottom-safety-pad {
      height: 5vh;
      min-height: 32px;
      background: var(--color-primary);
    }

    @media print {
      header,
      footer,
      #clinical-toggle,
      #sports-toggle,
      .tts-button,
      #download-chat,
      #speech-options-toggle {
        display: none !important;
      }

      body,
      #chat-log {
        overflow: visible !important;
        height: auto !important;
        background: white !important;
      }

      .msg-bot,
      .msg-user {
        border: 1px solid #e2e8f0 !important;
        box-shadow: none !important;
        break-inside: avoid;
      }
    }
  </style>
</head>
<body class="bg-white text-slate-900 h-screen flex flex-col overflow-hidden selection:bg-[#0052C4] selection:text-white">

  <!-- Header -->
  <header class="flex-none bg-white backdrop-blur-md border-b border-slate-200 p-4 flex items-center gap-4 z-20 shadow-sm">
    <div class="relative group cursor-pointer">
      <div class="absolute -inset-0.5 bg-gradient-to-r from-[#0052C4] to-[#1a73e8] rounded-full blur opacity-40 group-hover:opacity-80 transition duration-500"></div>
      <img
        src="./ross pic.png"
        alt="Ross Clark"
        class="relative w-12 h-12 rounded-full object-cover border-2 border-white"
        onerror="this.src='https://ui-avatars.com/api/?name=Ross+Clark&background=6366f1&color=fff'"
      />
      <div class="absolute bottom-0 right-0 w-3.5 h-3.5 bg-green-500 border-2 border-white rounded-full animate-pulse"></div>
    </div>
    
    <div class="flex-1 min-w-0">
      <h1 class="text-lg font-semibold text-slate-900 truncate flex items-center gap-2">
        Dr. Ross Clark
        <span class="px-2 py-0.5 rounded-full bg-[#0052C4]/10 text-[#0052C4] text-xs font-medium border border-[#0052C4]/20">AI Coach</span>
      </h1>
      <p class="text-xs text-slate-500 truncate">SPX102 Introduction to Coaching • Always Here for You!</p>
    </div>
    
    <div class="flex items-center gap-2 ml-auto">
      <button id="download-chat" class="inline-flex items-center gap-2 px-3 py-2 text-sm font-semibold text-white bg-[#0052C4] hover:bg-[#1a73e8] rounded-full shadow-sm transition-colors" type="button">
        <i data-lucide="download" class="w-4 h-4"></i>
        <span>Download Chat</span>
      </button>
      <div class="relative">
        <button id="speech-options-toggle" class="inline-flex items-center gap-2 px-3 py-2 text-sm font-semibold text-[#0052C4] border border-[#0052C4]/40 hover:border-[#0052C4] bg-white rounded-full shadow-sm transition-colors" type="button" aria-label="Speech options">
          <i data-lucide="sliders-horizontal" class="w-4 h-4"></i>
          <span>Speech options</span>
        </button>
        <div id="speech-options-panel" class="hidden absolute right-0 mt-3 w-64 rounded-2xl border border-slate-200 bg-white shadow-lg p-4 space-y-4 z-30">
          <div class="space-y-2">
            <p class="text-xs font-semibold text-slate-500 uppercase tracking-wide">Speech engine</p>
            <select id="speech-engine" class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 focus:outline-none focus:ring-2 focus:ring-[#0052C4]/40">
              <option value="huggingface">Hugging Face (English voices)</option>
              <option value="browser">Browser default (all languages)</option>
            </select>
          </div>
          <div class="space-y-2">
            <p class="text-xs font-semibold text-slate-500 uppercase tracking-wide">Voice</p>
            <div class="flex flex-col gap-2 text-sm text-slate-700">
              <label class="flex items-center gap-2">
                <input type="radio" name="speech-voice" value="female" class="accent-[#0052C4]" checked>
                Heart (Female)
              </label>
              <label class="flex items-center gap-2">
                <input type="radio" name="speech-voice" value="male" class="accent-[#0052C4]">
                Fenrir (Male)
              </label>
            </div>
          </div>
          <div class="space-y-2">
            <p class="text-xs font-semibold text-slate-500 uppercase tracking-wide">Speed</p>
            <select id="speech-speed" class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 focus:outline-none focus:ring-2 focus:ring-[#0052C4]/40">
              <option value="1">1x (Normal)</option>
              <option value="1.5">1.5x (Fast)</option>
              <option value="2">2x (Very fast)</option>
            </select>
          </div>
          <p class="text-[11px] text-slate-500 leading-relaxed">Tip: Choose browser speech for multilingual playback.</p>
        </div>
      </div>
      <button onclick="alert('I can only answer questions based on the SPX102 Notes.')" class="p-2 text-slate-500 hover:text-slate-900 transition-colors rounded-full hover:bg-slate-100" aria-label="Information about the chatbot">
        <i data-lucide="info" class="w-5 h-5"></i>
      </button>
    </div>
  </header>

  <!-- Chat Log -->
  <main id="chat-log" class="flex-1 overflow-y-auto custom-scroll p-4 space-y-6 scroll-smooth bg-white">

    <!-- Focus Toggles -->
    <section class="bg-slate-50 border border-slate-200 rounded-2xl p-4 shadow-sm space-y-3">
      <p class="text-sm text-slate-700">Select none, one or both to make the chatbot focus on sports, clinical or sports-related clinical examples</p>
      <div class="flex flex-wrap gap-3">
        <button id="clinical-toggle" type="button" class="focus:outline-none relative overflow-hidden rounded-xl border border-slate-200 bg-white transition hover:-translate-y-0.5 hover:border-[#0052C4]/70 active:scale-[0.99] p-2 shadow-sm">
          <img src="./clinical.png" alt="Clinical focus" class="w-24 h-24 object-cover rounded-lg" />
          <span class="sr-only">Toggle clinical focus</span>
        </button>
        <button id="sports-toggle" type="button" class="focus:outline-none relative overflow-hidden rounded-xl border border-slate-200 bg-white transition hover:-translate-y-0.5 hover:border-[#0052C4]/70 active:scale-[0.99] p-2 shadow-sm">
          <img src="./sports.png" alt="Sports focus" class="w-24 h-24 object-cover rounded-lg" />
          <span class="sr-only">Toggle sports focus</span>
        </button>
      </div>
    </section>
    
    <!-- Welcome Message -->
    <div class="flex gap-4">
      <img src="./ross pic.png" class="w-10 h-10 rounded-full object-cover border border-slate-200 flex-none self-end mb-1" alt="Bot">
      <div class="space-y-1 max-w-[85%]">
        <div class="text-xs text-slate-500 ml-1">Ro(bot)ss Clark</div>
        <div class="msg-bot bg-white border border-slate-200 p-4 text-sm leading-relaxed shadow-sm text-slate-800">
          <p>Hello! I'm your AI assistant for <span class="text-[#0052C4] font-semibold">SPX102 INTRODUCTION TO COACHING</span>.</p>
          <br>
          <p>I can help you understand coaching pedagogy, training principles and other aspects of your course. What should we discuss?</p>
        </div>
      </div>
    </div>

  </main>

  <!-- Typing Indicator (Hidden by default) -->
  <div id="typing-indicator" class="hidden px-4 pb-2">
    <div class="flex gap-4">
      <img src="./ross pic.png" class="w-8 h-8 rounded-full object-cover border border-slate-200 flex-none self-end opacity-70" alt="Bot">
      <div class="msg-bot bg-slate-100 border border-slate-200 p-3 rounded-2xl rounded-bl-none w-16 flex items-center justify-center h-10">
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
      </div>
    </div>
  </div>

  <!-- Input Area -->
  <footer class="flex-none p-4 bg-white backdrop-blur-lg border-t border-slate-200">
    <form id="chat-form" class="max-w-4xl mx-auto relative flex items-end gap-2">
      
      <div class="relative flex-1 bg-slate-50 border border-slate-200 rounded-2xl focus-within:ring-2 focus-within:ring-[#0052C4]/40 focus-within:border-[#0052C4] focus-within:bg-white transition-all duration-300 shadow-sm">
        <textarea
          id="user-input"
          rows="1"
          class="w-full bg-transparent text-slate-900 placeholder-slate-400 px-4 py-3.5 outline-none resize-none overflow-hidden max-h-32 text-sm"
          placeholder="Ask a question about coaching..."
          oninput="this.style.height = 'auto'; this.style.height = this.scrollHeight + 'px'"></textarea>
      </div>

      <div class="flex flex-col items-center gap-1">
        <button
          type="button"
          id="pdf-btn"
          class="flex-none h-[50px] w-[50px] border border-slate-200 bg-white text-slate-700 hover:text-[#0052C4] rounded-full flex items-center justify-center shadow-sm transition-all hover:scale-105 active:scale-95"
          aria-label="Attach PDF">
          <i data-lucide="paperclip" class="w-5 h-5"></i>
        </button>
        <input id="pdf-input" type="file" accept="application/pdf" class="hidden" />
        <div class="flex items-center gap-1">
          <span id="pdf-label" class="text-[10px] text-slate-500 text-center leading-tight">PDF</span>
          <button
            type="button"
            id="pdf-clear"
            class="hidden text-slate-400 hover:text-slate-700 transition-colors"
            aria-label="Remove PDF">
            <i data-lucide="x" class="w-3 h-3"></i>
          </button>
        </div>
      </div>

      <div class="flex flex-col items-center gap-1">
        <button
          type="button"
          id="mic-btn"
          class="flex-none h-[50px] w-[50px] border border-slate-200 bg-white text-slate-700 hover:text-[#0052C4] rounded-full flex items-center justify-center shadow-sm transition-all hover:scale-105 active:scale-95"
          aria-label="Toggle microphone mode">
          <i data-lucide="mic-off" class="w-5 h-5"></i>
        </button>
        <span id="mic-mode-label" class="text-[10px] text-slate-500 text-center leading-tight">Speech off</span>
      </div>

      <button 
        type="submit" 
        id="send-btn" 
        class="flex-none h-[50px] w-[50px] bg-[#0052C4] hover:bg-[#1a73e8] text-white rounded-full flex items-center justify-center shadow-lg shadow-blue-500/30 transition-all hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100">
        <i data-lucide="send" class="w-5 h-5 ml-0.5"></i>
      </button>

    </form>
    <div class="text-center mt-2">
       <span id="error" class="text-xs text-red-400 font-medium"></span>
       <span class="text-[10px] text-slate-500">I can only answer questions based on the SPX102 INTRODUCTION TO COACHING notes I was given.</span>
    </div>
  </footer>

  <div class="bottom-safety-pad flex-none w-full" aria-hidden="true"></div>

  <script>
    // Initialize Icons
    lucide.createIcons();

    const API_URL = "/.netlify/functions/openrouter-chat"; // Original Backend URL
    const HF_TTS_API = "/.netlify/functions/hf-tts";
    const HF_TTS_VOICES = {
      female: "af_heart",
      male: "am_fenrir",
    };
    const chatLog = document.getElementById("chat-log");
    const form = document.getElementById("chat-form");
    const textarea = document.getElementById("user-input");
    const errorSpan = document.getElementById("error");
    const sendBtn = document.getElementById("send-btn");
    const typingIndicator = document.getElementById("typing-indicator");
    const clinicalToggle = document.getElementById("clinical-toggle");
    const sportsToggle = document.getElementById("sports-toggle");
    const micBtn = document.getElementById("mic-btn");
    const micModeLabel = document.getElementById("mic-mode-label");
    const pdfBtn = document.getElementById("pdf-btn");
    const pdfInput = document.getElementById("pdf-input");
    const pdfLabel = document.getElementById("pdf-label");
    const pdfClearBtn = document.getElementById("pdf-clear");
    const downloadBtn = document.getElementById("download-chat");
    const speechOptionsToggle = document.getElementById("speech-options-toggle");
    const speechOptionsPanel = document.getElementById("speech-options-panel");
    const speechEngineSelect = document.getElementById("speech-engine");
    const speechSpeedSelect = document.getElementById("speech-speed");
    const speechVoiceInputs = document.querySelectorAll("input[name='speech-voice']");

    // Full message history
    let messages = [];
    let focusState = { clinical: false, sports: false };
    let pendingFocusInstruction = "";
    let activeAudio = null;
    let activeTtsButton = null;
    let activeUtterance = null;
    let lastUserPrompt = "";
    let narrativeModeEnabled = false;
    let narrativeModeInFlight = false;
    const ttsSpeedOptions = [1, 1.5, 2];
    let ttsSpeed = 1;
    let ttsEngine = "huggingface";
    let ttsVoice = "female";
    let ttsPlaybackToken = 0;
    let availableVoices = [];
    let pdfAttachment = null;

    // --- SPEECH RECOGNITION ---
    const SpeechMode = { OFF: 0, PUSH_TO_TALK: 1, CONTINUOUS: 2 };
    const speechModeLabels = ["Speech off", "Push-to-talk", "Continuous (auto-pause)"];
    const RecognitionClass = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognitionSupported = Boolean(RecognitionClass);
    let recognition;
    let isListening = false;
    let speechMode = SpeechMode.OFF;
    let speechBuffer = "";
    let activeTtsContentEl = null;
    let silenceTimer = null;
    let pausedForResponse = false;
    let awaitingResponse = false;
    let lastFinalTranscript = "";

    // --- KNOWLEDGE BASE (Restored) ---
    const knowledgeBase = `
## Assessment Tasks

### Task 1A – Coaching Knowledge & Conduct Modules (Weight: 10%, Due: Friday Week 4)
- Complete 4 online modules:
  - Play by the Rules (PBTR): Safeguarding Children and Young People in Sport Induction; Harassment and Discrimination.
  - Australian Sport Learning Centre: Community Coaching – Essential Skills; Community Officiating – General Principles.
- Submission: Save certificates (or screenshots), combine into a single PDF or Word file, and upload to Canvas.
- Goal: Demonstrate understanding of core coaching knowledge and professional conduct.

### Task 1B – Design a 1-Hour Coaching Session Plan (Weight: 20%, Due: Friday Week 8)
- Design a structured 1-hour lesson plan for any sport, event, or clinical condition using the provided template.
- Choose any sport recognized by the Australian Sports Commission.
- Format: PDF (preferred) or Word.
- AI Policy: Generative AI is allowed if used critically and acknowledged with a written declaration.
- Note: Attend the Week 6 workshop for feedback.

### Task 2 – Physical Capacity Testing (Weight: 50%, Due: Friday Week 13)
- Weeks 8–12: Perform one field-based physical test per week in scheduled labs with you as the coach.
- Submission:
  1. Video: One video of your best performance implementing a test with fellow students.
  2. Written Report: Max 400-word reflection on your coaching performance using the provided template.
- Goal: Implement, record, and analyse a field-based fitness test.
- Note: If you cannot record in class during Weeks 8–12, contact the Course Coordinator by Week 8.

### Task 3 – Centrally-Scheduled Exam (Weight: 20%, Exam window: TBD)
- Duration: 2 hours, fully online, open book; must be completed in one sitting once started.
- Content: Multiple choice and short answer questions covering theoretical content from the entire semester.
- AI Policy: AI is allowed.
- Warning: Do not start after 3pm on the Wednesday closing day to allow the full 2-hour window.

---
### Weekly Course Content
- Week 1: The Role of the Coach and Official
Coaching Frameworks & Competencies
•	Course Goal: Outcomes are modeled around industry standards (e.g., ESSA) such as applying basic testing and planning coaching sessions.
•	Framework Themes: Coaching is not "one-size-fits-all" and requires adjustment based on:
o	Specificity: Training must match the mode of the sport (e.g., sprinters vs. marathon runners).
o	Individuality: Adjusting for individual needs and learning preferences.
o	Inclusion: Maximizing involvement for all athletes.
•	Role of the Coach: To enhance performance (physical, cognitive, psychological, and emotional).
o	Modern Approach: Coaches act as facilitators or guides to help athletes develop robust motor programs, rather than relying solely on explicit instruction.
o	Communication: A coach must be able to pass on information; a great player may not be a great coach if they cannot identify deficiencies and communicate solutions.
Learning Modalities & Instruction
•	Learning Styles:
o	Visual: Need graphs, pictures, or demonstrations.
o	Auditory: Prefer listening.
o	Kinesthetic: Learn by "feeling" the body position.
o	Note: Most people are multimodal learners.
•	The Learning Process: A continuous loop: Instruction → Practice → Feedback → Learning Effect → Retention.
•	Effective Instruction:
o	Use short, simple keywords (reminders of technique). Avoid information overload (focus on 1–2 points).
o	Avoid pointing out "what not to do" as it confuses athletes.
o	Demonstrations: Must be performed correctly to avoid creating incorrect motor programs. Show at normal speed first to demonstrate timing.

Feedback Types
•	Task Intrinsic: Sensory info the athlete feels/sees naturally (visual, tactile, proprioceptive).
•	Augmented: Info from the coach.
o	Knowledge of Results (KR): The outcome (e.g., "Did you hit the target?").
o	Knowledge of Performance (KP): How the result was achieved (e.g., body position). Use carefully with beginners.
o	Sandwich Approach: Good point → Area for improvement → Good point.
The Role of the Official
•	Key Roles: Control the game (fairness/safety), make decisions (objective/quick), and communicate decisions.
•	Categories of Officials:
o	Interactors: High physical movement and interaction (e.g., Soccer referee).
o	Monitors: Low interaction, high cognitive tracking (e.g., Gymnastics judge).
o	Reactors: Low interaction/movement (e.g., Tennis line judge).
•	Cognitive Process: Stimulus → Perception → Categorization → Memory Access → Integration → Response.
•	Preparation: Officials should be trained like athletes, including fitness monitoring, vision/hearing tests, and cognitive training.

- Week 2: Talent Identification and Performance Testing
Talent Identification (TID)
•	Definition: Identifying individuals with promise to recruit them into formal training.
•	Subtypes:
o	Talent Selection: Identifying talent already participating in the sport (e.g., selecting representative teams).
o	Talent Detection: Recruiting athletes from outside the sport based on transferable attributes (e.g., anthropometry or physical skills).
•	Draft Combines: Physical testing batteries used to identify key attributes for professional selection (e.g., NBA, NFL).
Reliability & Validity
•	Reliability: Consistency of a measurement. A test is reliable if it yields the same result under the same conditions repeatedly. Controlled by standardizing protocols, equipment, and environment.
•	Validity: Accuracy of a measurement (does it measure what it intends to?). A test can be reliable (consistent) but not valid (consistently wrong).

Kinanthropometry
•	Definition: Measurement of body limb lengths, girths, and ratios to determine suitability for specific sports.
•	Key Measures:
o	Bone Growth: Tracked in youth to monitor growth rates.
o	Bone Density: Thicker bones resist impact damage; measured via DEXA.
o	Peak Height Velocity (PHV): The period of rapid growth during puberty. Training loads may need reduction during PHV to prevent overuse injuries.

- Week 3: Training Principles
Training Theory
•	Super Compensation: The cycle of adaptation where the body recovers and improves post-exercise. Training must be scheduled to hit this "peak".
•	Reversibility: "Use it or lose it"—capacities decrease if not trained.
•	Individuality: Athletes adapt differently due to genetics, training history, age (PHV considerations), and lifestyle factors.

Overload & FITT Principles
•	Overload: Modifying variables to increase work. Managed via:
o	Frequency: Sessions per week.
o	Intensity: Difficulty of the session.
o	Time/Duration: Length of the session.
o	Type: Specific drills or actions performed.
•	Specificity: Training must mimic the mode and demands of the competition (e.g., runners run, they don't just lift).
Recovery
•	Basics: Sleep and nutrition are fundamental.
•	Modalities: Cold water immersion and compression garments can improve jump performance and strength recovery.

- Week 4: Training Capacities
Physical Capacities
•	Endurance (Stamina): Ability to generate energy and minimize speed loss over time. Trained via long-distance intervals, repeat sprints, or small-sided games (manipulating pitch size).
•	Strength: Maximal force production.
o	Types: Maximal, Strength Endurance, Relative (ratio to body mass), Absolute (total force).
o	Training Targets: Hypertrophy (6-12 reps), Strength (1-6 reps), Power (1-5 reps, high velocity), Endurance (12-20+ reps).
•	Speed: Stride Length × Stride Frequency.
o	Training: Interval training, Resistance training, and Plyometrics (improve rate of force development).
•	Flexibility/Mobility: Range of motion (ROM) around a joint. Influenced by age, gender, temperature, and tissue properties.
o	Training: Static stretching (post-exercise), Dynamic stretching (pre-exercise), PNF.
Skill Acquisition
•	Components: Physical (technique) and Mental (decision-making).
•	Skilled vs. Unskilled: Highly skilled performers are more efficient (movement economy), consistent, and automated (freeing up cognitive space for tactics).
•	Training Skill: Practice should be repetitive, variable (different situations), contextual (game-like), and pressure-based.
Concurrent Training
•	Strength & Speed: Can be trained together (e.g., AM/PM split with 4-6 hours rest).
•	Endurance & Hypertrophy: Avoid combining in the same cycle; high risk of interference.
Week 5: Training, Planning, and Programming
Planning Levels
•	Quadrennial: 4-year cycle (Olympic). Can be Mono-cycle (1 peak) or Bi-cycle (2 peaks).
•	Macrocycle: Long-term block (usually 1 year).
•	Mesocycle: Medium block (4–6 weeks), specific objective.
•	Microcycle: Weekly block.

Periodisation Phases
1.	General Preparatory: High volume, moderate intensity. Focus on aerobic base and technique.
2.	Specific Preparatory: Reduced volume, higher intensity. Sport-specific conditioning and trial games.
3.	Pre-Competition: High intensity, low volume. Tactics and mental prep.
4.	Competition: Maintain capacities. High intensity, low volume. Tapering/Deloading.
5.	Transition (Off-Season): Active recovery and rehab.
Tapering
•	Short-term reduction in load before competition to reduce fatigue while maintaining fitness.
•	Modern Approach: Reduce volume, maintain intensity.
Microcycle Planning Example (In-Season)
•	Tuesday: Peak training (hardest session).
•	Wednesday-Friday: Tapering/Tactical.
•	Saturday: Match Day.
•	Sunday: Recovery.

- Week 6: Session Modification and Games-Based Learning
Dynamic Systems Theory (DST)
•	Skills emerge from the interaction of Constraints:
o	Task: Rules, equipment, field size.
o	Performer: Height, skill level, fatigue.
o	Environment: Weather, surface.
•	Self-Organization: Learners naturally adjust movements to solve problems posed by constraints (e.g., narrow pitch encourages vertical passing).
Modification Frameworks
•	TREE: Teaching style, Rules, Environment, Equipment.
•	CHANGE IT: Coaching style, How to score, Area, Numbers, Game rules, Equipment, Inclusion, Time.
•	TGfU (Teaching Games for Understanding): Uses modified games to teach skills/tactics under pressure rather than isolated drills.
Warm-Ups
•	Structure:
1.	Range of Motion (low load).
2.	Dynamic Component (3–5 mins).
3.	Skills Warm-up.
4.	Small-Sided Game.
•	Avoid: Static stretching immediately before performance (can reduce strength by ~30%).
Technique
•	Elite performers often have unorthodox styles (e.g., Don Bradman). No single "perfect" technique exists.
•	When to modify: Only for injury prevention or clear performance enhancement.

- Week 7: Long-Term Athlete Development (LTAD) Overview
LTAD Stages
1.	Active Start (0–6): Fundamental movement skills, play-based.
2.	FUNdamentals (6–9/10): Speed, agility, balance. Avoid early specialization.
3.	Learn to Train (8-11/9-12): Sport-specific skills begin, variety encouraged.
4.	Train to Train (11-15/12-16): Aerobic base, strength basics, PHV management.
5.	Train to Compete (15-21+): Specialization, high intensity.
6.	Train to Win (18+): Elite performance, winning focus.
7.	Active for Life: Lifelong participation.
Integration
•	LTAD provides the "big picture" (lifespan), while Periodisation provides the structure (Macro/Meso/Micro cycles) to achieve peaks.

- Week 8: LTAD - Learn to Train (LTT) & Train to Train (TTT)
Learn to Train (LTT)
•	Ages: Girls 8–11, Boys 9–12.
•	Focus: Sport-specific skills, coordination ("fine motor window").
•	Ratio: 70% Training, 30% Competition.
•	Content: Aerobic via games, strength via bodyweight/plyometrics.
Train to Train (TTT)
•	Ages: Girls 11–15, Boys 12–16.
•	Focus: "Build the engine" (aerobic/strength base). Puberty/PHV occurs here.
•	Ratio: 60% Training, 40% Competition.
•	Cognitive: Abstract thinking develops; introduce strategy and complex drills.
Growth Conditions (Overuse Injuries)
•	Osgood-Schlatter: Knee pain (tibial tuberosity).
•	Sever’s Disease: Heel pain (Achilles/calcaneus). Common in girls 8-10, boys 10-12.
•	Scheuermann’s: Thoracic kyphosis (wedging of vertebrae). Worsened by poor posture.
Youth Considerations
•	Thermoregulation: Children gain heat faster and sweat less. Drink breaks every 15–20 mins.
•	Equipment: Ensure correct shoe sizing (arch support) and bike fit (leg extension) to prevent joint stress.

- Week 9: LTAD - Train to Compete, Train to Win, Active for Life
Train to Compete (TTC)
•	Ages: Females 15–21, Males 16–23.
•	Focus: Optimize fitness, position-specific skills, recovery/ancillary capacities.
•	Specialization: 1–2 sports, year-round training.
•	Ratio: 40% Training, 60% Competition.
•	Phases: Initial Specialization (performance from growth + training) and Final Specialization (performance purely from training).
Train to Win (TTW)
•	Ages: 18/19+ (Elite).
•	Focus: Winning. Performance under pressure.
•	Ratio: 25% Training, 75% Competition.
•	Strategy: "2% Rule" (athletes within 2% of PB before comp likely to peak). Tapering is critical.
Active for Life (AFL)
•	Goal: Lifelong participation, health, and social connection.
•	Streams:
1.	Competitive for Life: Masters sports.
2.	Fit for Life: General health/activity (>60 min moderate activity).
3.	Sport Leaders: Coaching/Admin roles.

- Week 10: Coaching Female Athletes
Physiology & Classification
•	Sex vs. Gender: Sex is biological (chromosomes/hormones); Gender is identity.
•	Testosterone: Key driver of muscle mass, strength, and aerobic capacity. Males: 10–35 nmol/L; Females: 0.35–2.0 nmol/L.
•	IOC Policy: Moved from universal testosterone limits to sport-specific regulations in 2021.
Skeletal Differences & Injury Risk
•	Pelvis: Wider in females → increased Q-Angle (angle between quad and patella tendon) → higher risk of ACL injuries due to knee valgus (collapsing inward).
•	Prevention: Teach landing with hip/knee flexion; strengthen posterior chain (glutes/hamstrings).

Menstrual Cycle & The Triad
•	Cycle Phases: Menstrual/Follicular (Days 1-13), Ovulation (Day 14), Luteal (Days 15-28).
•	Luteal Phase: Progesterone raises body temp (heat stress risk) and Relaxin increases ligament laxity (injury risk).
•	Female Athlete Triad: Interrelation of Low Energy Availability (under-eating/over-training) → Menstrual Dysfunction (Amenorrhea) → Low Bone Mineral Density (Osteoporosis).
•	Amenorrhea: Absence of period for 3-6 months. Linked to stress fractures.

- Week 11: Coaching Diverse Populations
Ageing Athletes
•	Declines: Strength, power, VO2 max (~30-40% drop), and reaction time.
•	Bone Health: Osteoporosis risk increases. Best training: High-impact and resistance training (weights, jumping). Least effective: Swimming/cycling (low impact).
•	Sarcopenia: Loss of muscle mass (Type II fibers atrophy faster → power loss).
•	Screening: Mandatory ESSA screening for cardiac risk (Ischemia).

Athletes with Disability
•	Coaching Principle: "Do not treat them differently in fundamentals"—use same load monitoring and planning, just modify for impairments. Use TREE model to modify.
•	Spinal Cord Injury (SCI):
o	Thermoregulation: Sweating impaired below lesion → Overheating risk.
o	Autonomic Dysreflexia: Dangerous BP spikes from unseen pain stimuli.
•	Cerebral Palsy (CP): High muscle tone (spasticity). Prioritize stretching; spasticity can be triggered by rapid movements.
•	Amputees: Watch for skin breakdown in prosthesis and thermoregulation issues (less surface area to cool).

- Week 12: Future Trends in Sport
Data Analytics
•	Types:
o	Descriptive: What happened? (e.g., GPS distance) .
o	Diagnostic: Why did it happen? (e.g., video analysis of opposition press) .
o	Predictive: What will happen? (e.g., forecasting loads) .
o	Prescriptive: How do we make it happen? (e.g., selecting drills to meet specific load goals) .
•	Case Study (Brentford FC): Used data ("Hops" metric) to identify Ivan Toney's aerial dominance and employed a direct play style to bypass high-pressing teams.
AI in Sport
•	Officiating: Semi-automated offside tech (limb tracking + ball sensors at 500Hz).
•	Training: AI apps (e.g., Coach Cat) automate programming but need human oversight (e.g., an app might ignore poor sleep if HRV is fine).
Super Shoes
•	Tech: Carbon fiber plate + specialized foam.
•	Benefit: Improves running economy by ~4% (2% faster time).
•	Mechanism: Plate acts as a lever at ankle/toes; foam returns energy.
•	Coaching: Reduces heart rate at given speeds (adjust HR zones); potentially alters mechanics (forefoot strike).

 `.trim();

    // --- SYSTEM PROMPT BUILDER (Restored) ---
    function buildSystemPrompt() {
      return `
Your role:
- You are the SPX102 INTRODUCTION TO COACHING course chatbot. Answer only from the provided notes. You may respond in the same language the user uses to ask the question, or switch to the language the user asks you to use. 

You MUST follow these rules exactly:

1. PRIORITISE SAFETY OF THE USER
   - If the user appears to be in immediate danger, at risk of harming themselves, or describes serious harm from others:
     - Do NOT provide clinical advice.
     - Encourage them to seek urgent help.
     - Provide specific contacts such as:
       - Emergency services (e.g., call 000 in Australia).
       - National mental health helplines (e.g., Lifeline 13 11 14 in Australia).
       - Campus security and student support services (the teaching team will configure these for you).
   - Be warm, supportive, and non-judgemental.

2. ABSOLUTE SAFETY RESTRICTIONS
   - You must NEVER:
     - Provide instructions, methods, or encouragement for self-harm or suicide.
     - Provide guidance on illegal drugs, their manufacture, or their unsafe use.
     - Provide instructions for violence, weapons, or harming others.
   - If asked, clearly refuse and, where appropriate, gently steer the conversation to safety and wellbeing or back to course-related content.

3. STYLE
   - Use clear, concise explanations. Your responses should not exceeed 400 tokens unless absolutely necessary. 
   - When explaining difficult concepts, use simple examples aimed at university students.
   - When describing workflows, display the steps as a vertical list with emoji bullet points. Use bold headers for the action on each bullet, followed by details. Put "Tools" and "Why" on separate lines under the header.

KNOWLEDGE BASE (sole source of truth):
${knowledgeBase}
      `.trim();
    }

    // --- UI HELPER FUNCTIONS ---
    
    function escapeHtml(text) {
      return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function applyInlineFormatting(text) {
      const cleaned = text
        .replace(/<br\s*\/?>/gi, " ")
        .replace(/\u00a0|&nbsp;/gi, " ")
        .replace(/\s{2,}/g, " ");
      const escaped = escapeHtml(cleaned);
      const bolded = escaped.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
      return bolded.replace(/_(.*?)_/g, "<em>$1</em>");
    }

    function renderTable(lines, startIndex) {
      const rows = [];
      let i = startIndex;
      while (i < lines.length && lines[i].trim().startsWith("|")) {
        const row = lines[i]
          .trim()
          .replace(/^\||\|$/g, "")
          .split("|")
          .map((cell) => applyInlineFormatting(cell.trim()));
        rows.push(row);
        i++;
      }

      let header = [];
      let body = rows;

      if (rows.length > 1 && rows[1].every((cell) => /^-+$/.test(cell.replace(/<.*?>/g, "")))) {
        header = rows[0];
        body = rows.slice(2);
      }

      const headerHtml = header.length
        ? `<thead><tr>${header.map((cell) => `<th>${cell}</th>`).join("")}</tr></thead>`
        : "";
      const bodyHtml = body
        .map((row) => `<tr>${row.map((cell) => `<td>${cell}</td>`).join("")}</tr>`)
        .join("");

      return { html: `<table class="rich-text-table">${headerHtml}<tbody>${bodyHtml}</tbody></table>`, nextIndex: i - 1 };
    }

    function formatMessage(content) {
      const lines = content.trim().split("\n");
      let html = '<div class="rich-text space-y-2">';
      let inUl = false;
      let inOl = false;

      const closeLists = () => {
        if (inUl) {
          html += "</ul>";
          inUl = false;
        }
        if (inOl) {
          html += "</ol>";
          inOl = false;
        }
      };

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) {
          closeLists();
          continue;
        }

        // Tables
        if (line.startsWith("|")) {
          closeLists();
          const { html: tableHtml, nextIndex } = renderTable(lines, i);
          html += tableHtml;
          i = nextIndex;
          continue;
        }

        // Headings
        if (/^#{1,6}\s+/.test(line)) {
          closeLists();
          const level = line.match(/^#+/)[0].length;
          const text = applyInlineFormatting(line.replace(/^#{1,6}\s+/, ""));
          html += `<h${Math.min(level + 1, 4)}>${text}</h${Math.min(level + 1, 4)}>`;
          continue;
        }

        // Divider
        if (/^(-\s*){3,}$/.test(line)) {
          closeLists();
          html += "<hr/>";
          continue;
        }

        // Ordered List
        const orderedMatch = line.match(/^\d+\.\s+(.*)/);
        if (orderedMatch) {
          if (!inOl) {
            closeLists();
            inOl = true;
            html += '<ol class="pl-4">';
          }
          html += `<li>${applyInlineFormatting(orderedMatch[1])}</li>`;
          continue;
        }

        // Unordered List
        const unorderedMatch = line.match(/^[-*]\s+(.*)/);
        if (unorderedMatch) {
          if (!inUl) {
            closeLists();
            inUl = true;
            html += '<ul class="pl-4">';
          }
          html += `<li>${applyInlineFormatting(unorderedMatch[1])}</li>`;
          continue;
        }

        // Paragraph / Card block
        closeLists();
        const paragraph = applyInlineFormatting(line);
        const isEmphasized = paragraph.startsWith("<strong>") || paragraph.toLowerCase().startsWith("note:");
        html += `<div class="${isEmphasized ? "card-block" : ""}"><p>${paragraph}</p></div>`;
      }

      closeLists();
      html += "</div>";
      return html;
    }

    function setToggleState(button, isActive) {
      button.setAttribute("aria-pressed", isActive);
      const highlightClasses = [
        "ring-4",
        "ring-offset-2",
        "ring-offset-white",
        "ring-[var(--color-secondary)]",
        "border-[var(--color-secondary)]",
        "bg-[var(--color-secondary)]/20",
        "shadow-lg",
        "shadow-yellow-200/80",
      ];

      highlightClasses.forEach((cls) => button.classList.toggle(cls, isActive));
    }

    function collectChatEntries() {
      const entries = [];
      chatLog.querySelectorAll(".msg-user, .msg-bot").forEach((node) => {
        const role = node.classList.contains("msg-user") ? "You" : "Coach Ross";
        const content = node.innerHTML.trim();
        if (content) {
          entries.push({ role, content });
        }
      });
      return entries;
    }

    function downloadChat() {
      const entries = collectChatEntries();
      if (!entries.length) {
        errorSpan.textContent = "No chat to download yet.";
        return;
      }
      errorSpan.textContent = "";
      window.print();
    }

    function updatePendingFocusInstruction() {
      const { clinical, sports } = focusState;
      if (clinical && sports) {
        pendingFocusInstruction = "use examples specific to sports related clinical exercise physiology";
      } else if (clinical) {
        pendingFocusInstruction = "use an example appropriate to clinical exercise physiology that is not sports related";
      } else if (sports) {
        pendingFocusInstruction = "use an example appropriate to sports that is not clinical exercise physiology related";
      } else {
        pendingFocusInstruction = "";
      }
    }

    function addUserMessage(content, attachmentName) {
        const attachmentHtml = attachmentName
          ? `
            <div class="mt-2 inline-flex items-center gap-1 rounded-full bg-white/70 px-2 py-1 text-[11px] text-slate-700">
              <i data-lucide="file-text" class="w-3.5 h-3.5"></i>
              <span>${escapeHtml(attachmentName)}</span>
            </div>
          `
          : "";
        const div = document.createElement("div");
        div.className = "flex gap-4 flex-row-reverse animate-[fadeIn_0.3s_ease-out]";
        div.innerHTML = `
            <div class="space-y-1 max-w-[85%]">
                <div class="msg-user bg-[var(--color-secondary)] text-black p-4 text-sm leading-relaxed shadow-lg">
                    ${formatMessage(content)}
                    ${attachmentHtml}
                </div>
            </div>
        `;
        chatLog.appendChild(div);
        chatLog.scrollTop = chatLog.scrollHeight;
        lucide.createIcons();
    }

    function scrollMessageToTop(element) {
        const containerRect = chatLog.getBoundingClientRect();
        const elementRect = element.getBoundingClientRect();
        const offset = elementRect.top - containerRect.top + chatLog.scrollTop;
        chatLog.scrollTo({ top: offset, behavior: "smooth" });
    }

    function addBotMessage(content) {
        const div = document.createElement("div");
        div.className = "flex gap-4 animate-[slideIn_0.3s_ease-out]";
        div.innerHTML = `
             <img src="./ross pic.png"
                  class="w-10 h-10 rounded-full object-cover border border-slate-200 flex-none self-end mb-1"
                  alt="Ross Clark"
                  onerror="this.src='https://ui-avatars.com/api/?name=Ross+Clark&background=6366f1&color=fff'">
            <div class="space-y-1 max-w-[85%]">
                <div class="text-xs text-slate-500 ml-1">Ross Clark</div>
                <div class="flex items-start gap-2">
                  <div class="msg-bot bg-white border border-slate-200 p-4 text-sm leading-relaxed shadow-sm text-slate-800" data-role="bot-content">
                      ${formatMessage(content)}
                  </div>
                  <button
                    type="button"
                    class="tts-button h-9 w-9 rounded-full flex items-center justify-center shadow-sm"
                    data-role="tts-button"
                    data-state="idle"
                    aria-label="Play message audio"
                    title="Play audio"
                    disabled>
                    <i data-lucide="volume-2" class="w-4 h-4"></i>
                  </button>
                </div>
            </div>
        `;
        chatLog.appendChild(div);
        const contentEl = div.querySelector("[data-role='bot-content']");
        const ttsButton = div.querySelector("[data-role='tts-button']");
        ttsButton.addEventListener("click", () => handleTtsButtonClick(ttsButton));
        lucide.createIcons();
        scrollMessageToTop(contentEl);
        return { contentEl, ttsButton };
    }

    function setTtsButtonState(button, state) {
      button.dataset.state = state;
      if (state === "loading") {
        button.setAttribute("aria-label", "Stop message audio");
        button.setAttribute("title", "Stop audio");
      } else {
        button.setAttribute("aria-label", "Play message audio");
        button.setAttribute("title", "Play audio");
      }
    }

    function setTtsButtonText(button, text) {
      button.dataset.ttsText = text;
      button.disabled = !text;
    }

    function clearTtsHighlights(container) {
      if (!container) return;
      const highlights = container.querySelectorAll(".tts-highlight");
      highlights.forEach((highlight) => {
        const textNode = document.createTextNode(highlight.textContent || "");
        highlight.replaceWith(textNode);
      });
      container.normalize();
    }

    function getTextNodesWithOffsets(container) {
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
      const nodes = [];
      let index = 0;
      let node;
      while ((node = walker.nextNode())) {
        const value = node.nodeValue || "";
        const length = value.length;
        if (length) {
          nodes.push({ node, start: index, end: index + length });
          index += length;
        }
      }
      return nodes;
    }

    function getContainerText(container) {
      if (!container) return "";
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
      let text = "";
      let node;
      while ((node = walker.nextNode())) {
        text += node.nodeValue || "";
      }
      return text;
    }

    function highlightTextRange(container, start, end) {
      if (!container) return;
      clearTtsHighlights(container);
      if (start >= end) return;
      const nodes = getTextNodesWithOffsets(container);
      nodes.forEach(({ node, start: nodeStart, end: nodeEnd }) => {
        if (nodeEnd <= start || nodeStart >= end) return;
        let workingNode = node;
        const startOffset = Math.max(start - nodeStart, 0);
        const endOffset = Math.min(end - nodeStart, workingNode.nodeValue.length);
        if (endOffset < workingNode.nodeValue.length) {
          workingNode.splitText(endOffset);
        }
        if (startOffset > 0) {
          workingNode = workingNode.splitText(startOffset);
        }
        const highlightSpan = document.createElement("span");
        highlightSpan.className = "tts-highlight";
        highlightSpan.textContent = workingNode.nodeValue;
        workingNode.replaceWith(highlightSpan);
      });
    }

    function splitIntoSentences(text) {
      const sentences = [];
      if (!text) return sentences;
      const regex = /[^.!?\;;:]+[.!?\;;:]+|[^.!?\;;:]+$/g;
      let match;
      let offset = 0;
      while ((match = regex.exec(text)) !== null) {
        const chunk = match[0];
        const trimmed = chunk.trim();
        if (!trimmed) {
          offset += chunk.length;
          continue;
        }
        const leadingWhitespace = chunk.indexOf(trimmed);
        const start = offset + leadingWhitespace;
        const end = start + trimmed.length;
        sentences.push({ text: trimmed, start, end });
        offset += chunk.length;
      }
      return sentences;
    }

    function stopActiveAudio() {
      ttsPlaybackToken += 1;
      if (activeAudio) {
        activeAudio.pause();
        activeAudio.currentTime = 0;
      }
      if (activeUtterance && "speechSynthesis" in window) {
        window.speechSynthesis.cancel();
      }
      if (activeTtsButton) {
        setTtsButtonState(activeTtsButton, "idle");
      }
      if (activeTtsContentEl) {
        clearTtsHighlights(activeTtsContentEl);
      }
      activeAudio = null;
      activeTtsButton = null;
      activeUtterance = null;
      activeTtsContentEl = null;
    }

    function detectLanguageTag(text) {
      const sample = text.slice(0, 500);
      if (/[\u4e00-\u9fff]/.test(sample)) return "zh";
      if (/[\u3040-\u30ff]/.test(sample)) return "ja";
      if (/[\uac00-\ud7af]/.test(sample)) return "ko";
      if (/[\u0400-\u04ff]/.test(sample)) return "ru";
      if (/[\u0600-\u06ff]/.test(sample)) return "ar";
      if (/[\u0900-\u097f]/.test(sample)) return "hi";
      if (/[\u0590-\u05ff]/.test(sample)) return "he";
      if (/[\u0e00-\u0e7f]/.test(sample)) return "th";
      if (/[¿¡ñáéíóúü]/i.test(sample)) return "es";
      if (/[àâçéèêëîïôùûüÿœ]/i.test(sample)) return "fr";
      return "en";
    }

    function refreshVoices() {
      if (!("speechSynthesis" in window)) return;
      availableVoices = window.speechSynthesis.getVoices() || [];
    }

    function selectSpeechSynthesisVoice(lang) {
      if (!availableVoices.length) refreshVoices();
      const normalized = lang.toLowerCase();
      return (
        availableVoices.find((voice) => voice.lang?.toLowerCase().startsWith(normalized)) ||
        availableVoices.find((voice) => voice.lang?.toLowerCase().startsWith(normalized.split("-")[0])) ||
        null
      );
    }

    async function playBrowserSpeech(text, lang, button, contentEl) {
      if (!("speechSynthesis" in window)) {
        throw new Error("Speech synthesis is not available.");
      }
      stopActiveAudio();
      const playbackToken = ttsPlaybackToken;
      setTtsButtonState(button, "loading");
      const sentences = splitIntoSentences(text);
      if (!sentences.length) {
        setTtsButtonState(button, "idle");
        return;
      }
      activeTtsButton = button;
      activeTtsContentEl = contentEl || null;
      return new Promise((resolve, reject) => {
        let index = 0;
        const speakNext = () => {
          if (playbackToken !== ttsPlaybackToken) {
            resolve();
            return;
          }
          if (index >= sentences.length) {
            setTtsButtonState(button, "idle");
            if (activeTtsButton === button) activeTtsButton = null;
            activeUtterance = null;
            if (activeTtsContentEl) {
              clearTtsHighlights(activeTtsContentEl);
            }
            resolve();
            return;
          }
          const sentence = sentences[index];
          const utterance = new SpeechSynthesisUtterance(sentence.text);
          const voice = selectSpeechSynthesisVoice(lang);
          if (voice) utterance.voice = voice;
          utterance.lang = lang;
          utterance.rate = ttsSpeed;
          activeUtterance = utterance;
          if (activeTtsContentEl) {
            highlightTextRange(activeTtsContentEl, sentence.start, sentence.end);
          }
          utterance.onend = () => {
            if (playbackToken !== ttsPlaybackToken) {
              resolve();
              return;
            }
            index += 1;
            speakNext();
          };
          utterance.onerror = () => {
            setTtsButtonState(button, "idle");
            if (activeTtsButton === button) activeTtsButton = null;
            activeUtterance = null;
            if (activeTtsContentEl) {
              clearTtsHighlights(activeTtsContentEl);
            }
            reject(new Error("Unable to play the generated audio."));
          };
          window.speechSynthesis.speak(utterance);
        };
        window.speechSynthesis.cancel();
        speakNext();
      });
    }

   // A simple queue to hold pre-fetched audio blobs
let audioQueue = [];

async function playTtsForText(text, button, contentEl) {
  const speechText = contentEl ? getContainerText(contentEl).trim() : text?.trim();
  if (!speechText) return;

  if (ttsEngine === "browser") {
    const lang = detectLanguageTag(speechText);
    await playBrowserSpeech(speechText, lang, button, contentEl);
    return;
  }

  stopActiveAudio();
  const playbackToken = ttsPlaybackToken;
  setTtsButtonState(button, "loading");
  activeTtsButton = button;
  activeTtsContentEl = contentEl || null;
  
  const sentences = splitIntoSentences(speechText);
  audioQueue = []; // Reset queue

  try {
    for (let i = 0; i < sentences.length; i++) {
      if (playbackToken !== ttsPlaybackToken) break;
      const sentence = sentences[i];
      
      // 1. Fetch the current sentence if it's not already in the queue
      let audioBlob;
      if (audioQueue[i]) {
        audioBlob = audioQueue[i];
      } else {
        audioBlob = await fetchAudioBlob(sentence.text);
      }

      if (playbackToken !== ttsPlaybackToken) break;

      // 2. Start pre-fetching the NEXT sentence in the background (don't 'await' it)
      if (i + 1 < sentences.length) {
        fetchAudioBlob(sentences[i + 1].text).then(blob => {
          audioQueue[i + 1] = blob;
        });
      }

      // 3. Play the current audio and wait for it to finish
      await playAudioFromBlob(audioBlob, button, contentEl, sentence, playbackToken);
    }
  } catch (err) {
    console.error("TTS Queue Error:", err);
    errorSpan.textContent = "Playback error. Switching to browser speech.";
    const lang = detectLanguageTag(speechText);
    await playBrowserSpeech(speechText, lang, button, contentEl);
  } finally {
    if (playbackToken === ttsPlaybackToken) {
      setTtsButtonState(button, "idle");
      if (activeTtsContentEl) {
        clearTtsHighlights(activeTtsContentEl);
      }
      activeTtsButton = null;
      activeTtsContentEl = null;
    }
  }
}

// Helper to ONLY fetch the audio from your Netlify function
async function fetchAudioBlob(text) {
  const response = await fetch(HF_TTS_API, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text, voice: HF_TTS_VOICES[ttsVoice], speed: ttsSpeed }),
  });

  if (!response.ok) throw new Error("Fetch failed");
  return await response.blob();
}

// Helper to ONLY play the audio and handle highlighting
function playAudioFromBlob(blob, button, contentEl, sentenceMetadata, playbackToken) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(blob);
    const audio = new Audio(url);
    activeAudio = audio;

    if (playbackToken !== ttsPlaybackToken) {
      URL.revokeObjectURL(url);
      resolve();
      return;
    }

    if (contentEl && sentenceMetadata) {
      highlightTextRange(contentEl, sentenceMetadata.start, sentenceMetadata.end);
    }

    audio.onended = () => {
      URL.revokeObjectURL(url);
      resolve();
    };
    audio.onpause = () => {
      if (playbackToken !== ttsPlaybackToken) {
        URL.revokeObjectURL(url);
        resolve();
      }
    };
    audio.onerror = reject;
    audio.play().catch(reject);
  });
}

    async function handleTtsButtonClick(button) {
      const contentEl = button.closest(".space-y-1")?.querySelector("[data-role='bot-content']");
      const text = contentEl ? getContainerText(contentEl).trim() : button.dataset.ttsText?.trim();
      if (button.dataset.state === "loading") {
        stopActiveAudio();
        return;
      }
      if (!text) return;
      errorSpan.textContent = "";
      if (!narrativeModeEnabled && contentEl) {
        await handleNarrativeModeRequest({ button, contentEl });
        return;
      }
      await playTtsForText(text, button, contentEl);
    }

    function setTyping(isTyping) {
      if (isTyping) {
        typingIndicator.classList.remove("hidden");
        sendBtn.disabled = true;
        sendBtn.classList.add("opacity-50", "cursor-not-allowed");
        chatLog.appendChild(typingIndicator); 
        chatLog.scrollTop = chatLog.scrollHeight;
      } else {
        typingIndicator.classList.add("hidden");
        sendBtn.disabled = false;
        sendBtn.classList.remove("opacity-50", "cursor-not-allowed");
      }
    }

    // --- LOGIC RESTORATION ---

    function initMessages() {
      messages = [
        {
          role: "system",
          content: buildSystemPrompt(),
        },
      ];
    }

    function updateSpeechOptionsUI() {
      if (speechSpeedSelect) {
        speechSpeedSelect.value = `${ttsSpeed}`;
      }
      if (speechEngineSelect) {
        speechEngineSelect.value = ttsEngine;
      }
      speechVoiceInputs.forEach((input) => {
        input.checked = input.value === ttsVoice;
        input.disabled = ttsEngine !== "huggingface";
      });
    }

    function truncateFileName(name, maxLength = 22) {
      if (!name) return "";
      if (name.length <= maxLength) return name;
      const extIndex = name.lastIndexOf(".");
      const ext = extIndex > -1 ? name.slice(extIndex) : "";
      const base = name.slice(0, maxLength - ext.length - 1);
      return `${base}…${ext}`;
    }

    function getSessionId() {
      const storageKey = "chat_session_id";
      const existing = localStorage.getItem(storageKey);
      if (existing) return existing;
      const generated =
        (window.crypto?.randomUUID && window.crypto.randomUUID()) ||
        `session_${Date.now()}_${Math.random().toString(16).slice(2)}`;
      localStorage.setItem(storageKey, generated);
      return generated;
    }

    async function logToFirebase(role, content) {
      try {
        await fetch("/.netlify/functions/log-chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            userId: getSessionId(),
            role,
            content,
            timestamp: new Date().toISOString(),
          }),
        });
      } catch (err) {
        console.error("Failed to log to Firebase", err);
      }
    }

    function resetPdfAttachment() {
      pdfAttachment = null;
      if (pdfInput) {
        pdfInput.value = "";
      }
      if (pdfLabel) {
        pdfLabel.textContent = "PDF";
        pdfLabel.title = "";
      }
      if (pdfClearBtn) {
        pdfClearBtn.classList.add("hidden");
      }
    }

    function setPdfAttachment(file, dataUrl) {
      pdfAttachment = {
        name: file.name,
        dataUrl,
      };
      if (pdfLabel) {
        pdfLabel.textContent = truncateFileName(file.name);
        pdfLabel.title = file.name;
      }
      if (pdfClearBtn) {
        pdfClearBtn.classList.remove("hidden");
      }
    }
    
    // Initialise on load
    initMessages();

    // Set initial toggle appearance
    setToggleState(clinicalToggle, focusState.clinical);
    setToggleState(sportsToggle, focusState.sports);

    // Focus toggle interactions
    clinicalToggle.addEventListener("click", () => {
      focusState.clinical = !focusState.clinical;
      setToggleState(clinicalToggle, focusState.clinical);
      updatePendingFocusInstruction();
    });

    sportsToggle.addEventListener("click", () => {
      focusState.sports = !focusState.sports;
      setToggleState(sportsToggle, focusState.sports);
      updatePendingFocusInstruction();
    });

    // Crisis detection
    function looksLikeCrisis(text) {
      const lowered = text.toLowerCase();
      const keywords = ["kill myself", "suicide", "want to die", "end my life", "self harm", "self-harm", "hurt myself"];
      return keywords.some((k) => lowered.includes(k));
    }

    function crisisResponse() {
      return `I'm really glad you reached out — your safety is the most important thing.
      <br><br>
      I can't provide crisis counselling, but please consider these options right now:
      <br>• If you are in immediate danger call <strong>000</strong> (Australia).
      <br>• Contact <strong>Lifeline</strong> on <strong>13 11 14</strong>.
      <br>• If you are a student, please contact your university's student wellbeing team.
      <br><br>You do not have to go through this alone.`;
    }

    async function streamAssistantResponseInto({ messagesToSend, contentEl, ttsButton }) {
      const decoder = new TextDecoder();
      let assistantContent = "";
      let buffer = "";
      let streamEnded = false;

      const includesFile = messagesToSend.some(
        (message) =>
          Array.isArray(message.content) &&
          message.content.some((part) => part?.type === "file")
      );
      const requestBody = {
        messages: messagesToSend,
        stream: true,
      };
      if (includesFile) {
        requestBody.plugins = [
          {
            id: "file-parser",
            pdf: {
              engine: "pdf-text",
            },
          },
        ];
      }

      const response = await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const rawText = await response.text();
        let backendMsg = "The server returned an error.";
        try {
          const parsed = JSON.parse(rawText);
          if (parsed?.error) {
            backendMsg =
              typeof parsed.error === "string"
                ? parsed.error
                : parsed.error.message || backendMsg;
          }
        } catch (e) {
          // ignore
        }
        errorSpan.textContent = "Error: " + backendMsg;
        const fallbackText = "Sorry, I couldn't generate a response just now.";
        contentEl.innerHTML = formatMessage(fallbackText);
        setTtsButtonText(ttsButton, fallbackText);
        return assistantContent;
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error("Readable stream not available");
      }

      while (!streamEnded) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });

        while (true) {
          const lineEnd = buffer.indexOf("\n");
          if (lineEnd === -1) break;

          const line = buffer.slice(0, lineEnd).trim();
          buffer = buffer.slice(lineEnd + 1);

          if (!line || line.startsWith(":")) continue;
          if (!line.startsWith("data: ")) continue;

          const dataStr = line.slice(6);
          if (dataStr === "[DONE]") {
            streamEnded = true;
            break;
          }

          try {
            const parsed = JSON.parse(dataStr);

            if (parsed?.error) {
              const msg =
                parsed.error?.message || "An error occurred during streaming.";
              errorSpan.textContent = "Error: " + msg;
              streamEnded = true;
              break;
            }

            const delta = parsed?.choices?.[0]?.delta?.content || "";
            if (delta) {
              assistantContent += delta;
              contentEl.innerHTML = formatMessage(assistantContent);
            }

            const finishReason = parsed?.choices?.[0]?.finish_reason;
            if (finishReason === "stop" || finishReason === "length") {
              streamEnded = true;
              break;
            }
          } catch (err) {
            // Ignore malformed SSE payloads
          }
        }
      }

      if (assistantContent) {
        setTtsButtonText(ttsButton, assistantContent);
      }
      return assistantContent;
    }

    async function streamAssistantResponse() {
      const { contentEl: botContentEl, ttsButton } = addBotMessage("");
      ttsButton.dataset.userPrompt = lastUserPrompt;
      return streamAssistantResponseInto({
        messagesToSend: messages,
        contentEl: botContentEl,
        ttsButton,
      });
    }

    async function handleNarrativeModeRequest({ button, contentEl }) {
      if (narrativeModeInFlight) return;
      narrativeModeInFlight = true;
      const narrativeInstruction =
        "Answer all further questions in narrative style with no tables or bullet points.";
      const narrativeUserInstruction =
        "You must respond in narrative format with no tables or bullet points.";
      const placeholderText =
        "I'm just converting this response to a better format for speech - I'll be ready soon and all further responses will be done like this straight away!";
      const originalText = button.dataset.ttsText?.trim() || "";
      const priorPrompt = button.dataset.userPrompt?.trim() || lastUserPrompt.trim();
      narrativeModeEnabled = true;
      messages.push({ role: "system", content: narrativeInstruction });

      contentEl.innerHTML = formatMessage(placeholderText);
      setTtsButtonText(button, "");
      setTtsButtonState(button, "loading");

      const narrativeRequest = priorPrompt
        ? `Please rewrite your last response in narrative form. Prior prompt:\n${priorPrompt}`
        : "Please rewrite your last response in narrative form.";
      const narrativeMessages = [
        ...messages,
        {
          role: "user",
          content: `${narrativeUserInstruction}\n\n${narrativeRequest}`,
        },
      ];

      try {
        const assistantReply = await streamAssistantResponseInto({
          messagesToSend: narrativeMessages,
          contentEl,
          ttsButton: button,
        });
        if (assistantReply) {
          await playTtsForText(assistantReply, button, contentEl);
        } else if (originalText) {
          contentEl.innerHTML = formatMessage(originalText);
          setTtsButtonText(button, originalText);
        }
      } catch (err) {
        console.error(err);
        if (originalText) {
          contentEl.innerHTML = formatMessage(originalText);
          setTtsButtonText(button, originalText);
        }
        errorSpan.textContent = "Could not reformat the response for speech.";
      } finally {
        narrativeModeInFlight = false;
      }
    }

    // --- SPEECH HELPERS ---
    function startSilenceTimer() {
      clearTimeout(silenceTimer);
      silenceTimer = setTimeout(() => finalizeSpeechInput(), 2000);
    }

    function finalizeSpeechInput() {
      clearTimeout(silenceTimer);
      silenceTimer = null;
      if (!speechBuffer.trim()) return;
      const spokenText = speechBuffer.trim();
      speechBuffer = "";
      // Prevent auto-restart when continuous mode hits the silence boundary
      if (speechMode === SpeechMode.CONTINUOUS) {
        pausedForResponse = true;
        stopListening();
      }
      handleUserMessage(spokenText, { triggeredBySpeech: true });
    }

    function handleSpeechResult(event) {
      let added = false;
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const result = event.results[i];
        if (!result?.isFinal) continue;
        const transcript = result[0].transcript.trim();
        if (!transcript || transcript === lastFinalTranscript) continue;

        const normalizedBuffer = speechBuffer.toLowerCase();
        const normalizedTranscript = transcript.toLowerCase();
        const alreadyCaptured =
          normalizedBuffer && normalizedTranscript.startsWith(normalizedBuffer);
        const addition = alreadyCaptured
          ? transcript.slice(speechBuffer.length).trim()
          : transcript;

        if (addition) {
          speechBuffer = speechBuffer ? `${speechBuffer} ${addition}`.trim() : addition;
          added = true;
        } else if (!alreadyCaptured) {
          speechBuffer = transcript;
          added = true;
        }

        lastFinalTranscript = transcript;
      }

      if (added) {
        startSilenceTimer();
      }
    }

    function handleSpeechError(event) {
      const friendlyMessage =
        event.error === "not-allowed" || event.error === "service-not-allowed"
          ? "Microphone permission was blocked."
          : `Speech recognition error: ${event.error}`;
      errorSpan.textContent = friendlyMessage;
      speechMode = SpeechMode.OFF;
      stopListening();
      updateMicButtonUI();
    }

    function handleRecognitionEnd() {
      isListening = false;
      updateMicButtonUI();
      // Continuous mode will be resumed explicitly after the model response.
    }

    function initSpeechRecognition() {
      if (!recognitionSupported) {
        micBtn.disabled = true;
        micBtn.classList.add("opacity-50", "cursor-not-allowed");
        micModeLabel.textContent = "Speech not supported";
        return;
      }
      recognition = new RecognitionClass();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = "en-US";
      recognition.onresult = handleSpeechResult;
      recognition.onerror = handleSpeechError;
      recognition.onend = handleRecognitionEnd;
      recognition.onstart = () => {
        isListening = true;
        updateMicButtonUI();
      };
    }

    function startListening() {
      if (!recognitionSupported || !recognition || isListening || pausedForResponse) return;
      speechBuffer = "";
      lastFinalTranscript = "";
      try {
        recognition.start();
        isListening = true;
      } catch (err) {
        console.error(err);
      }
      updateMicButtonUI();
    }

    function stopListening() {
      clearTimeout(silenceTimer);
      silenceTimer = null;
      speechBuffer = "";
      lastFinalTranscript = "";
      if (recognitionSupported && recognition && isListening) {
        try {
          recognition.stop();
        } catch (err) {
          console.error(err);
        }
      }
      isListening = false;
      updateMicButtonUI();
    }

    function pauseRecognitionForResponse() {
      if (!recognitionSupported) return;
      pausedForResponse = true;
      stopListening();
    }

    function resumeRecognitionAfterResponse() {
      if (!recognitionSupported) return;
      pausedForResponse = false;
      if (speechMode === SpeechMode.CONTINUOUS) {
        startListening();
      }
    }

    function updateMicButtonUI() {
      const icon = speechMode === SpeechMode.OFF ? "mic-off" : pausedForResponse ? "pause-circle" : "mic";
      micBtn.innerHTML = `<i data-lucide="${icon}" class="w-5 h-5"></i>`;
      lucide.createIcons();
      micModeLabel.textContent = speechModeLabels[speechMode] || "Speech off";
      micBtn.classList.toggle("bg-[#0052C4]", speechMode !== SpeechMode.OFF && isListening);
      micBtn.classList.toggle("text-white", speechMode !== SpeechMode.OFF && isListening);
      micBtn.classList.toggle("border-[#0052C4]", speechMode !== SpeechMode.OFF && isListening);
    }

    function setSpeechMode(mode) {
      if (!recognitionSupported && mode !== SpeechMode.OFF) {
        errorSpan.textContent = "Speech recognition is not available in this browser.";
        speechMode = SpeechMode.OFF;
        stopListening();
        updateMicButtonUI();
        return;
      }
      speechMode = mode;
      speechBuffer = "";
      pausedForResponse = false;
      clearTimeout(silenceTimer);
      if (speechMode === SpeechMode.OFF) {
        stopListening();
      } else {
        startListening();
      }
      updateMicButtonUI();
    }

    function cycleSpeechMode() {
      const nextMode = (speechMode + 1) % 3;
      setSpeechMode(nextMode);
    }

    // Unified user message handler (text or speech)
    async function handleUserMessage(userText, { triggeredBySpeech = false } = {}) {
      errorSpan.textContent = "";
      const cleanedText = userText.trim();
      const hasPdf = Boolean(pdfAttachment);
      if (!cleanedText && !hasPdf) return;
      const fallbackPrompt = cleanedText || "Please review the attached PDF.";
      lastUserPrompt = fallbackPrompt;
      const narrativeUserInstruction =
        "You must respond in narrative format with no tables or bullet points.";

      const focusPrefix = pendingFocusInstruction ? `${pendingFocusInstruction}. ` : "";
      const narrativePrefix = narrativeModeEnabled ? `${narrativeUserInstruction} ` : "";
      const messageToSend = `${focusPrefix}${narrativePrefix}${fallbackPrompt}`.trim();
      pendingFocusInstruction = "";

      const userLogText = cleanedText || "PDF attached.";
      addUserMessage(userLogText, pdfAttachment?.name);
      logToFirebase("user", userLogText);
      const contentPayload = hasPdf
        ? [
            { type: "text", text: messageToSend },
            {
              type: "file",
              file: {
                filename: pdfAttachment.name,
                file_data: pdfAttachment.dataUrl,
              },
            },
          ]
        : messageToSend;
      messages.push({ role: "user", content: contentPayload }); // Update history
      if (hasPdf) {
        resetPdfAttachment();
      }

      if (!triggeredBySpeech) {
        textarea.value = "";
        textarea.style.height = 'auto'; // Reset height
      }
      
      setTyping(true);
      awaitingResponse = true;

      if (speechMode === SpeechMode.CONTINUOUS) {
        pauseRecognitionForResponse();
      }

      // Local Crisis Check
      if (looksLikeCrisis(cleanedText)) {
        setTimeout(() => {
            const supportText = crisisResponse();
            const { ttsButton } = addBotMessage(supportText);
            setTtsButtonText(ttsButton, supportText);
            ttsButton.dataset.userPrompt = cleanedText;
            messages.push({ role: "assistant", content: supportText });
            logToFirebase("assistant", supportText);
            awaitingResponse = false;
            setTyping(false);
            resumeRecognitionAfterResponse();
        }, 1000); 
        return;
      }

      // Backend Call with streaming
      try {
        const assistantReply = await streamAssistantResponse();
        if (assistantReply) {
          messages.push({ role: "assistant", content: assistantReply });
          logToFirebase("assistant", assistantReply);
        }
      } catch (err) {
        console.error(err);
        errorSpan.textContent = "Network error connecting to backend.";
      } finally {
        awaitingResponse = false;
        setTyping(false);
        if (speechMode === SpeechMode.PUSH_TO_TALK) {
          stopListening();
        } else if (speechMode === SpeechMode.CONTINUOUS) {
          resumeRecognitionAfterResponse();
        }
      }
    }

    // Form Submission
    form.addEventListener("submit", (event) => {
      event.preventDefault();
      handleUserMessage(textarea.value);
    });

    // Handle Enter key
    textarea.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            form.dispatchEvent(new Event("submit"));
        }
    });

    pdfBtn?.addEventListener("click", () => {
      pdfInput?.click();
    });

    pdfInput?.addEventListener("change", () => {
      errorSpan.textContent = "";
      const file = pdfInput.files?.[0];
      if (!file) {
        resetPdfAttachment();
        return;
      }
      const isPdf =
        file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf");
      if (!isPdf) {
        errorSpan.textContent = "Please choose a PDF file.";
        resetPdfAttachment();
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        const result = reader.result;
        if (typeof result === "string") {
          setPdfAttachment(file, result);
        } else {
          errorSpan.textContent = "Unable to read the PDF file.";
          resetPdfAttachment();
        }
      };
      reader.onerror = () => {
        errorSpan.textContent = "Unable to read the PDF file.";
        resetPdfAttachment();
      };
      reader.readAsDataURL(file);
    });

    pdfClearBtn?.addEventListener("click", () => {
      resetPdfAttachment();
    });

    initSpeechRecognition();
    updateMicButtonUI();
    refreshVoices();
    updateSpeechOptionsUI();
    if ("speechSynthesis" in window) {
      window.speechSynthesis.onvoiceschanged = refreshVoices;
    }

    micBtn.addEventListener("click", () => {
      if (speechMode === SpeechMode.PUSH_TO_TALK && !isListening && !awaitingResponse && recognitionSupported) {
        startListening();
        return;
      }
      if (speechMode === SpeechMode.CONTINUOUS && !isListening && !awaitingResponse && recognitionSupported) {
        startListening();
        return;
      }
      cycleSpeechMode();
    });

    speechOptionsToggle?.addEventListener("click", () => {
      speechOptionsPanel?.classList.toggle("hidden");
    });

    document.addEventListener("click", (event) => {
      if (!speechOptionsPanel || !speechOptionsToggle) return;
      const target = event.target;
      if (!(target instanceof Node)) return;
      if (
        speechOptionsPanel.classList.contains("hidden") ||
        speechOptionsPanel.contains(target) ||
        speechOptionsToggle.contains(target)
      ) {
        return;
      }
      speechOptionsPanel.classList.add("hidden");
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        speechOptionsPanel?.classList.add("hidden");
      }
    });

    speechEngineSelect?.addEventListener("change", (event) => {
      const value = event.target.value;
      if (value === "huggingface" || value === "browser") {
        ttsEngine = value;
      }
      stopActiveAudio();
      updateSpeechOptionsUI();
    });

    speechSpeedSelect?.addEventListener("change", (event) => {
      const value = Number(event.target.value);
      if (ttsSpeedOptions.includes(value)) {
        ttsSpeed = value;
        if (activeUtterance) {
          activeUtterance.rate = ttsSpeed;
        }
      }
      updateSpeechOptionsUI();
    });

    speechVoiceInputs.forEach((input) => {
      input.addEventListener("change", () => {
        if (input.checked) {
          ttsVoice = input.value === "male" ? "male" : "female";
        }
        updateSpeechOptionsUI();
      });
    });

    downloadBtn?.addEventListener("click", downloadChat);

  </script>
</body>
</html>
