<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Course Chatbot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <!-- Tailwind CSS for modern styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    :root {
      font-family: 'Open Sans', sans-serif;
      --color-primary: #0052C4;
      --color-secondary: #fce726;
      --color-surface: #ffffff;
      --color-muted: #f8fafc;
      --color-border: #e2e8f0;
      --color-text: #0f172a;
      --color-subtle: #475569;
    }
    
    /* Custom Scrollbar */
    .scrollbar-hide::-webkit-scrollbar {
        display: none;
    }
    .scrollbar-hide {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }
    
    .custom-scroll::-webkit-scrollbar {
      width: 6px;
    }
    .custom-scroll::-webkit-scrollbar-track {
      background: rgba(226, 232, 240, 0.8);
    }
    .custom-scroll::-webkit-scrollbar-thumb {
      background-color: #94a3b8;
      border-radius: 20px;
    }

    /* Message Bubbles */
    .msg-user {
      border-radius: 18px 18px 4px 18px;
    }
    .msg-bot {
      border-radius: 18px 18px 18px 4px;
    }

    .msg-user,
    .msg-bot,
    .rich-text {
      word-break: break-word;
      overflow-wrap: anywhere;
      hyphens: auto;
      max-width: 100%;
    }

    /* Bounce animation for dots */
    .typing-dot {
      animation: bounce 1.4s infinite ease-in-out both;
      background-color: #94a3b8; 
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
      margin: 0 2px;
    }
    
    .typing-dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-dot:nth-child(2) { animation-delay: -0.16s; }
    
    @keyframes bounce {
      0%, 80%, 100% { transform: scale(0); }
      40% { transform: scale(1); }
    }

    /* Gradient Text */
    .text-gradient {
      background: linear-gradient(to right, #0052C4, #1a73e8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    /* Rich text styling for bot replies */
    .rich-text {
      color: var(--color-text);
    }
    .rich-text h2,
    .rich-text h3,
    .rich-text h4 {
      font-weight: 700;
      letter-spacing: -0.01em;
      color: var(--color-primary);
      margin-bottom: 0.35rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }
    .rich-text h2::before,
    .rich-text h3::before,
    .rich-text h4::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 9999px;
      background: linear-gradient(135deg, #0052C4, #1a73e8);
      box-shadow: 0 0 0 6px rgba(0, 82, 196, 0.08);
    }
    .rich-text p {
      margin-bottom: 0.75rem;
      line-height: 1.7;
    }
    .rich-text ul {
      list-style: none;
      padding-left: 0;
      margin: 0.5rem 0 1rem;
      display: grid;
      gap: 0.35rem;
    }
    .rich-text ul li {
      position: relative;
      padding-left: 1.2rem;
    }
    .rich-text ul li::before {
      content: "•";
      position: absolute;
      left: 0;
      top: 0;
      color: var(--color-primary);
      font-weight: 700;
    }
    .rich-text ol {
      counter-reset: item;
      padding-left: 0;
      margin: 0.5rem 0 1rem;
      display: grid;
      gap: 0.35rem;
    }
    .rich-text ol li {
      counter-increment: item;
      padding-left: 1.6rem;
      position: relative;
    }
    .rich-text ol li::before {
      content: counter(item) ".";
      position: absolute;
      left: 0;
      top: 0;
      color: var(--color-primary);
      font-weight: 700;
    }
    .rich-text hr {
      border: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(148, 163, 184, 0.4), transparent);
      margin: 1.5rem 0;
    }
    .rich-text table {
      width: 100%;
      max-width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 12px;
      overflow: hidden;
      background: #f8fafc;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      display: block;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .rich-text th,
    .rich-text td {
      padding: 0.65rem 0.9rem;
      text-align: left;
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
    }
    .rich-text th {
      background: linear-gradient(90deg, rgba(0, 82, 196, 0.12), rgba(26, 115, 232, 0.08));
      color: #0f172a;
      font-weight: 700;
      letter-spacing: 0.01em;
      text-transform: uppercase;
      font-size: 0.75rem;
    }
    .rich-text tr:last-child td {
      border-bottom: none;
    }
    .rich-text strong {
      color: #0f172a;
      font-weight: 700;
    }
    .rich-text .card-block {
      background: linear-gradient(145deg, rgba(0, 82, 196, 0.06), rgba(240, 247, 255, 0.9));
      border: 1px solid rgba(0, 82, 196, 0.25);
      padding: 1rem;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0, 82, 196, 0.08);
      backdrop-filter: blur(6px);
      margin-bottom: 0.9rem;
    }

    .tts-button {
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: #475569;
      background: #f8fafc;
      transition: all 0.2s ease;
    }
    .tts-button:hover {
      color: #0052C4;
      border-color: rgba(0, 82, 196, 0.6);
      background: #eff6ff;
    }
    .tts-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .tts-button[data-state="loading"] {
      color: #0052C4;
      border-color: rgba(0, 82, 196, 0.4);
      background: rgba(219, 234, 254, 0.6);
      animation: ttsPulse 1.1s ease-in-out infinite;
    }
    .tts-button[data-state="loading"] svg {
      animation: ttsSpin 1s linear infinite;
    }
    .tts-highlight {
      background-color: var(--color-secondary);
      border-radius: 6px;
      box-decoration-break: clone;
      -webkit-box-decoration-break: clone;
    }
    .copy-button {
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: #475569;
      background: #f8fafc;
      transition: all 0.2s ease;
    }
    .copy-button:hover {
      color: #0052C4;
      border-color: rgba(0, 82, 196, 0.6);
      background: #eff6ff;
    }
    .copy-button[data-state="copied"] {
      color: #0f172a;
      border-color: rgba(14, 116, 144, 0.55);
      background: rgba(224, 242, 254, 0.9);
    }
    @keyframes ttsPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.08); }
    }
    @keyframes ttsSpin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .bottom-safety-pad {
      height: 5vh;
      min-height: 32px;
      background: var(--color-primary);
    }

    @media print {
      header,
      footer,
      #clinical-toggle,
      #sports-toggle,
      .tts-button,
      .copy-button,
      #download-chat,
      #speech-options-toggle {
        display: none !important;
      }

      body,
      #chat-log {
        overflow: visible !important;
        height: auto !important;
        background: white !important;
      }

      .msg-bot,
      .msg-user {
        border: 1px solid #e2e8f0 !important;
        box-shadow: none !important;
        break-inside: avoid;
      }
    }
  </style>
</head>
<body class="bg-white text-slate-900 h-screen flex flex-col overflow-hidden selection:bg-[#0052C4] selection:text-white">

  <!-- Header -->
  <header class="flex-none bg-white backdrop-blur-md border-b border-slate-200 p-4 flex items-center gap-4 z-20 shadow-sm">
    <div class="relative group cursor-pointer">
      <div class="absolute -inset-0.5 bg-gradient-to-r from-[#0052C4] to-[#1a73e8] rounded-full blur opacity-40 group-hover:opacity-80 transition duration-500"></div>
      <img
        data-role="bot-avatar"
        src=""
        alt=""
        data-fallback=""
        class="relative w-12 h-12 rounded-full object-cover border-2 border-white"
        onerror="if (this.dataset.fallback) { this.src = this.dataset.fallback; }"
      />
      <div class="absolute bottom-0 right-0 w-3.5 h-3.5 bg-green-500 border-2 border-white rounded-full animate-pulse"></div>
    </div>
    
    <div class="flex-1 min-w-0">
      <h1 class="text-lg font-semibold text-slate-900 truncate flex items-center gap-2">
        <span data-role="bot-display-name">Course Bot</span>
        <span data-role="bot-badge" class="px-2 py-0.5 rounded-full bg-[#0052C4]/10 text-[#0052C4] text-xs font-medium border border-[#0052C4]/20">AI Coach</span>
      </h1>
      <p data-role="bot-subtitle" class="text-xs text-slate-500 truncate">Course chatbot</p>
    </div>
    
    <div class="flex items-center gap-2 ml-auto">
      <button id="download-chat" class="inline-flex items-center gap-2 px-3 py-2 text-sm font-semibold text-white bg-[#0052C4] hover:bg-[#1a73e8] rounded-full shadow-sm transition-colors" type="button">
        <i data-lucide="download" class="w-4 h-4"></i>
        <span>Download Chat</span>
      </button>
      <div class="relative">
        <button id="speech-options-toggle" class="inline-flex items-center gap-2 px-3 py-2 text-sm font-semibold text-[#0052C4] border border-[#0052C4]/40 hover:border-[#0052C4] bg-white rounded-full shadow-sm transition-colors" type="button" aria-label="Speech options">
          <i data-lucide="sliders-horizontal" class="w-4 h-4"></i>
          <span>Speech options</span>
        </button>
        <div id="speech-options-panel" class="hidden absolute right-0 mt-3 w-64 rounded-2xl border border-slate-200 bg-white shadow-lg p-4 space-y-4 z-30">
          <div class="space-y-2">
            <p class="text-xs font-semibold text-slate-500 uppercase tracking-wide">Speech engine</p>
            <select id="speech-engine" class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 focus:outline-none focus:ring-2 focus:ring-[#0052C4]/40">
              <option value="huggingface">Hugging Face (English voices)</option>
              <option value="browser">Browser default (all languages)</option>
            </select>
          </div>
          <div class="space-y-2">
            <p class="text-xs font-semibold text-slate-500 uppercase tracking-wide">Voice</p>
            <div class="flex flex-col gap-2 text-sm text-slate-700">
              <label class="flex items-center gap-2">
                <input type="radio" name="speech-voice" value="female" class="accent-[#0052C4]" checked>
                Heart (Female)
              </label>
              <label class="flex items-center gap-2">
                <input type="radio" name="speech-voice" value="male" class="accent-[#0052C4]">
                Fenrir (Male)
              </label>
            </div>
          </div>
          <div class="space-y-2">
            <p class="text-xs font-semibold text-slate-500 uppercase tracking-wide">Speed</p>
            <select id="speech-speed" class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 focus:outline-none focus:ring-2 focus:ring-[#0052C4]/40">
              <option value="1">1x (Normal)</option>
              <option value="1.5">1.5x (Fast)</option>
              <option value="2">2x (Very fast)</option>
            </select>
          </div>
          <p class="text-[11px] text-slate-500 leading-relaxed">Tip: Choose browser speech for multilingual playback.</p>
        </div>
      </div>
      <button id="bot-info-button" class="p-2 text-slate-500 hover:text-slate-900 transition-colors rounded-full hover:bg-slate-100" aria-label="Information about the chatbot">
        <i data-lucide="info" class="w-5 h-5"></i>
      </button>
    </div>
  </header>

  <!-- Chat Log -->
  <main id="chat-log" class="flex-1 overflow-y-auto custom-scroll p-4 space-y-6 scroll-smooth bg-white">

    <!-- Focus Toggles -->
    <section class="bg-slate-50 border border-slate-200 rounded-2xl p-4 shadow-sm space-y-3">
      <p class="text-sm text-slate-700">Select none, one or both to make the chatbot focus on sports, clinical or sports-related clinical examples</p>
      <div class="flex flex-wrap gap-3">
        <button id="clinical-toggle" type="button" class="focus:outline-none relative overflow-hidden rounded-xl border border-slate-200 bg-white transition hover:-translate-y-0.5 hover:border-[#0052C4]/70 active:scale-[0.99] p-2 shadow-sm">
          <img src="./clinical.png" alt="Clinical focus" class="w-24 h-24 object-cover rounded-lg" />
          <span class="sr-only">Toggle clinical focus</span>
        </button>
        <button id="sports-toggle" type="button" class="focus:outline-none relative overflow-hidden rounded-xl border border-slate-200 bg-white transition hover:-translate-y-0.5 hover:border-[#0052C4]/70 active:scale-[0.99] p-2 shadow-sm">
          <img src="./sports.png" alt="Sports focus" class="w-24 h-24 object-cover rounded-lg" />
          <span class="sr-only">Toggle sports focus</span>
        </button>
      </div>
    </section>
    
    <!-- Welcome Message -->
    <div class="flex gap-4">
      <img data-role="bot-avatar-small" src="" data-fallback="" class="w-10 h-10 rounded-full object-cover border border-slate-200 flex-none self-end mb-1" alt="">
      <div class="space-y-1 max-w-[85%]">
        <div data-role="bot-welcome-name" class="text-xs text-slate-500 ml-1">Course Bot</div>
        <div class="msg-bot bg-white border border-slate-200 p-4 text-sm leading-relaxed shadow-sm text-slate-800">
          <div data-role="bot-content">
            <p>Hello! I'm your AI assistant for <span data-role="bot-welcome-title" class="text-[#0052C4] font-semibold">your course</span>.</p>
            <br>
            <p data-role="bot-welcome-message">I can help you with your course. What should we discuss?</p>
          </div>
          <div data-role="followup-container" class="mt-3 flex flex-wrap gap-2 hidden"></div>
        </div>
        <div class="mt-2 flex items-center gap-2 text-xs text-slate-500">
          <button type="button" class="copy-button inline-flex h-8 w-8 items-center justify-center rounded-full shadow-sm" data-role="copy-button" aria-label="Copy message text" title="Copy text">
            <i data-lucide="copy" class="w-4 h-4"></i>
          </button>
          <span>Copy</span>
        </div>
      </div>
    </div>

  </main>

  <!-- Typing Indicator (Hidden by default) -->
  <div id="typing-indicator" class="hidden px-4 pb-2">
    <div class="flex gap-4">
      <img data-role="bot-avatar-typing" src="" data-fallback="" class="w-8 h-8 rounded-full object-cover border border-slate-200 flex-none self-end opacity-70" alt="">
      <div class="msg-bot bg-slate-100 border border-slate-200 p-3 rounded-2xl rounded-bl-none w-16 flex items-center justify-center h-10">
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
      </div>
    </div>
  </div>

  <!-- Input Area -->
  <footer class="flex-none p-4 bg-white backdrop-blur-lg border-t border-slate-200">
    <form id="chat-form" class="max-w-4xl mx-auto relative flex items-end gap-2">
      
      <div class="relative flex-1 bg-slate-50 border border-slate-200 rounded-2xl focus-within:ring-2 focus-within:ring-[#0052C4]/40 focus-within:border-[#0052C4] focus-within:bg-white transition-all duration-300 shadow-sm">
        <textarea
          id="user-input"
          rows="1"
          class="w-full bg-transparent text-slate-900 placeholder-slate-400 px-4 py-3.5 outline-none resize-none overflow-hidden max-h-32 text-sm"
          placeholder="Ask a question about coaching..."
          oninput="this.style.height = 'auto'; this.style.height = this.scrollHeight + 'px'"></textarea>
      </div>

      <div class="flex flex-col items-center gap-1">
        <button
          type="button"
          id="pdf-btn"
          class="flex-none h-[50px] w-[50px] border border-slate-200 bg-white text-slate-700 hover:text-[#0052C4] rounded-full flex items-center justify-center shadow-sm transition-all hover:scale-105 active:scale-95"
          aria-label="Attach PDF">
          <i data-lucide="paperclip" class="w-5 h-5"></i>
        </button>
        <input id="pdf-input" type="file" accept="application/pdf" class="hidden" />
        <div class="flex items-center gap-1">
          <span id="pdf-label" class="text-[10px] text-slate-500 text-center leading-tight">PDF</span>
          <button
            type="button"
            id="pdf-clear"
            class="hidden text-slate-400 hover:text-slate-700 transition-colors"
            aria-label="Remove PDF">
            <i data-lucide="x" class="w-3 h-3"></i>
          </button>
        </div>
      </div>

      <div class="flex flex-col items-center gap-1">
        <button
          type="button"
          id="mic-btn"
          class="flex-none h-[50px] w-[50px] border border-slate-200 bg-white text-slate-700 hover:text-[#0052C4] rounded-full flex items-center justify-center shadow-sm transition-all hover:scale-105 active:scale-95"
          aria-label="Toggle microphone mode">
          <i data-lucide="mic-off" class="w-5 h-5"></i>
        </button>
        <span id="mic-mode-label" class="text-[10px] text-slate-500 text-center leading-tight">Speech off</span>
      </div>

      <button 
        type="submit" 
        id="send-btn" 
        class="flex-none h-[50px] w-[50px] bg-[#0052C4] hover:bg-[#1a73e8] text-white rounded-full flex items-center justify-center shadow-lg shadow-blue-500/30 transition-all hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100">
        <i data-lucide="send" class="w-5 h-5 ml-0.5"></i>
      </button>

    </form>
    <div class="text-center mt-2">
       <span id="error" class="text-xs text-red-400 font-medium"></span>
       <span data-role="bot-note-footer" class="text-[10px] text-slate-500">I can only answer questions based on the notes I was given.</span>
    </div>
  </footer>

  <div class="bottom-safety-pad flex-none w-full" aria-hidden="true"></div>

  <script>
    // Initialize Icons
    lucide.createIcons();

    const API_URL = "/.netlify/functions/openrouter-chat"; // Original Backend URL
    const HF_TTS_API = "/.netlify/functions/hf-tts";
    const HF_TTS_VOICES = {
      female: "af_heart",
      male: "am_fenrir",
    };
    const chatLog = document.getElementById("chat-log");
    const form = document.getElementById("chat-form");
    const textarea = document.getElementById("user-input");
    const errorSpan = document.getElementById("error");
    const sendBtn = document.getElementById("send-btn");
    const typingIndicator = document.getElementById("typing-indicator");
    const clinicalToggle = document.getElementById("clinical-toggle");
    const sportsToggle = document.getElementById("sports-toggle");
    const micBtn = document.getElementById("mic-btn");
    const micModeLabel = document.getElementById("mic-mode-label");
    const pdfBtn = document.getElementById("pdf-btn");
    const pdfInput = document.getElementById("pdf-input");
    const pdfLabel = document.getElementById("pdf-label");
    const pdfClearBtn = document.getElementById("pdf-clear");
    const downloadBtn = document.getElementById("download-chat");
    const speechOptionsToggle = document.getElementById("speech-options-toggle");
    const speechOptionsPanel = document.getElementById("speech-options-panel");
    const speechEngineSelect = document.getElementById("speech-engine");
    const speechSpeedSelect = document.getElementById("speech-speed");
    const speechVoiceInputs = document.querySelectorAll("input[name='speech-voice']");
    const botAvatar = document.querySelector("[data-role='bot-avatar']");
    const botAvatarSmall = document.querySelector("[data-role='bot-avatar-small']");
    const botAvatarTyping = document.querySelector("[data-role='bot-avatar-typing']");
    const botDisplayNameEl = document.querySelector("[data-role='bot-display-name']");
    const botBadgeEl = document.querySelector("[data-role='bot-badge']");
    const botSubtitleEl = document.querySelector("[data-role='bot-subtitle']");
    const botWelcomeNameEl = document.querySelector("[data-role='bot-welcome-name']");
    const botWelcomeTitleEl = document.querySelector("[data-role='bot-welcome-title']");
    const botWelcomeMessageEl = document.querySelector("[data-role='bot-welcome-message']");
    const botNoteFooterEl = document.querySelector("[data-role='bot-note-footer']");
    const botInfoButton = document.getElementById("bot-info-button");

    // Full message history
    let messages = [];
    let focusState = { clinical: false, sports: false };
    let pendingFocusInstruction = "";
    let activeAudio = null;
    let globalAudioElement = new Audio();
    let activeTtsButton = null;
    let activeUtterance = null;
    let lastUserPrompt = "";
    let narrativeModeEnabled = false;
    let narrativeModeInFlight = false;
    let tutorModeEnabled = false;
    const tutorModeSystemInstruction = `You are a Socratic tutor. Your goal is to guide me to understand the topic we are discussing.
Do not give me direct answers. Instead, ask probing, open-ended questions one at a time.
Wait for my response before asking the next question.
Help me identify gaps in my reasoning, challenge assumptions, and build my own understanding.
Continue until I can explain the concept back to you.

Start by asking me what I already know about the topic we are discussing.`;
    const tutorModeExitInstruction =
      "Exit Socratic tutor mode and respond in the default helpful assistant style with direct answers.";
    const tutorModeExitPrompt =
      "I’m done with the Socratic tutor mode exercise. Please just explain the concept to me plainly now.";
    const ttsSpeedOptions = [1, 1.5, 2];
    let ttsSpeed = 1;
    let ttsEngine = "huggingface";
    let ttsVoice = "female";
    let ttsPlaybackToken = 0;
    let availableVoices = [];
    let autoTtsEnabled = false;
    let pdfAttachment = null;

    // --- SPEECH RECOGNITION ---
    const SpeechMode = { OFF: 0, PUSH_TO_TALK: 1, CONTINUOUS: 2 };
    const speechModeLabels = ["Speech off", "Push-to-talk", "Continuous (auto-pause)"];
    const RecognitionClass = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognitionSupported = Boolean(RecognitionClass);
    let recognition;
    let isListening = false;
    let speechMode = SpeechMode.OFF;
    let speechBuffer = "";
    let activeTtsContentEl = null;
    let silenceTimer = null;
    let pausedForResponse = false;
    let pausedForTts = false;
    let awaitingResponse = false;
    let lastFinalTranscript = "";

    // --- BOT CONFIGURATION ---
    const defaultBotId = "SPX102";
    let botConfig = null;
    let instructionsText = "";
    let knowledgeBaseText = "";
    let botDisplayName = "Course Bot";
    let botShortName = "Bot";
    let botBadgeLabel = "AI Coach";
    let botSubtitle = "";
    let botProfileImageUrl = "";
    let botFallbackAvatarUrl = "";
    let botInfoMessage = "";
    let botWelcomeName = "";
    let botWelcomeTitle = "";
    let botWelcomeMessage = "";
    let botNoteFooter = "";


    // --- SYSTEM PROMPT BUILDER ---
    function buildSystemPrompt() {
      const instructionBlock = instructionsText.trim();
      const knowledgeBlock = knowledgeBaseText.trim();
      const sections = [];
      if (instructionBlock) {
        sections.push(instructionBlock);
      }
      if (knowledgeBlock) {
        sections.push("KNOWLEDGE BASE (sole source of truth):", knowledgeBlock);
      }
      return sections.join("\n\n").trim();
    }

    function escapeAttribute(value) {
      return String(value || "").replace(/"/g, "&quot;");
    }

    function applyBotImage(imgEl, { src, fallback, alt }) {
      if (!imgEl) return;
      const resolvedSrc = src || fallback || "";
      if (resolvedSrc) {
        imgEl.src = resolvedSrc;
      }
      if (fallback) {
        imgEl.dataset.fallback = fallback;
      }
      if (alt) {
        imgEl.alt = alt;
      }
      imgEl.onerror = () => {
        if (imgEl.dataset.fallback && imgEl.src !== imgEl.dataset.fallback) {
          imgEl.src = imgEl.dataset.fallback;
        }
      };
    }

    function setChatEnabled(enabled, placeholderText = "Ask a question about coaching...") {
      if (textarea) {
        textarea.disabled = !enabled;
        textarea.placeholder = placeholderText;
      }
      if (sendBtn) {
        sendBtn.disabled = !enabled;
      }
      if (pdfBtn) {
        pdfBtn.disabled = !enabled;
      }
      if (micBtn) {
        micBtn.disabled = !enabled;
      }
    }

    function applyBotConfig(config) {
      botConfig = config;
      botDisplayName = config.displayName || config.shortName || "Course Bot";
      botShortName = config.shortName || config.displayName || "Bot";
      botBadgeLabel = config.badgeLabel || botBadgeLabel;
      botSubtitle = config.subtitle || "";
      botProfileImageUrl = config.profileImageUrl || "";
      botFallbackAvatarUrl = config.fallbackAvatarUrl || "";
      botInfoMessage = config.infoMessage || "";
      botWelcomeName = config.welcomeName || botShortName;
      botWelcomeTitle = config.welcomeTitle || "";
      botWelcomeMessage = config.welcomeMessage || "";
      botNoteFooter = config.noteFooter || "";

      document.title = config.title || botDisplayName;

      if (botDisplayNameEl) {
        botDisplayNameEl.textContent = botDisplayName;
      }
      if (botBadgeEl) {
        botBadgeEl.textContent = botBadgeLabel;
        botBadgeEl.classList.toggle("hidden", !botBadgeLabel);
      }
      if (botSubtitleEl) {
        botSubtitleEl.textContent = botSubtitle;
        botSubtitleEl.classList.toggle("hidden", !botSubtitle);
      }
      if (botWelcomeNameEl) {
        botWelcomeNameEl.textContent = botWelcomeName;
      }
      if (botWelcomeTitleEl) {
        botWelcomeTitleEl.textContent = botWelcomeTitle;
      }
      if (botWelcomeMessageEl) {
        botWelcomeMessageEl.textContent = botWelcomeMessage;
      }
      if (botNoteFooterEl) {
        botNoteFooterEl.textContent = botNoteFooter;
      }

      const imageConfig = {
        src: botProfileImageUrl,
        fallback: botFallbackAvatarUrl,
        alt: botDisplayName,
      };
      applyBotImage(botAvatar, imageConfig);
      applyBotImage(botAvatarSmall, imageConfig);
      applyBotImage(botAvatarTyping, imageConfig);
    }

    function getBotIdFromPath() {
      const path = window.location.pathname.replace(/\/+$/, "");
      if (!path || path === "/" || path.endsWith("/chatbot.html")) return null;
      const slug = path.split("/").filter(Boolean)[0];
      return slug ? decodeURIComponent(slug) : null;
    }

    async function fetchBotConfigPayload(botId) {
      const url = new URL("/.netlify/functions/bot-config", window.location.origin);
      if (botId) {
        url.searchParams.set("bot", botId);
      }
      const response = await fetch(url);
      let data = {};
      try {
        data = await response.json();
      } catch (error) {
        data = {};
      }
      return { response, data };
    }

    async function fetchBotFromStaticFiles(botId) {
      const basePath = `/bots/${encodeURIComponent(botId)}`;
      const [configRes, instructionsRes, knowledgeRes] = await Promise.all([
        fetch(`${basePath}/config.json`),
        fetch(`${basePath}/instructions.md`),
        fetch(`${basePath}/knowledgebase.md`),
      ]);
      if (!configRes.ok || !instructionsRes.ok || !knowledgeRes.ok) {
        throw new Error("Static bot files not found.");
      }
      return {
        bot: await configRes.json(),
        instructions: await instructionsRes.text(),
        knowledgeBase: await knowledgeRes.text(),
      };
    }

    async function initializeBot() {
      setChatEnabled(false, "Loading bot configuration...");
      const urlBotId = getBotIdFromPath();
      const queryBotId = new URLSearchParams(window.location.search).get("bot");
      let requestedBotId = urlBotId || queryBotId;
      let payload;

      try {
        if (!requestedBotId) {
          const listResult = await fetchBotConfigPayload();
          if (listResult.response.ok && listResult.data?.bots?.length) {
            requestedBotId = listResult.data.bots[0].id;
          } else {
            requestedBotId = defaultBotId;
          }
        }

        const { response, data } = await fetchBotConfigPayload(requestedBotId);
        if (response.ok && data?.bot) {
          payload = data;
        } else if (data?.availableBots?.length) {
          requestedBotId = data.availableBots[0].id;
          const followUp = await fetchBotConfigPayload(requestedBotId);
          if (followUp.response.ok && followUp.data?.bot) {
            payload = followUp.data;
          }
        }
      } catch (error) {
        console.warn("Primary bot-config fetch failed:", error);
      }

      if (!requestedBotId) {
        requestedBotId = defaultBotId;
      }

      if (!payload) {
        const isLocalhost =
          window.location.hostname === "localhost" ||
          window.location.hostname === "127.0.0.1";
        if (isLocalhost && requestedBotId) {
          try {
            payload = await fetchBotFromStaticFiles(requestedBotId);
          } catch (error) {
            console.warn("Static bot load failed:", error);
          }
        }
      }

      if (!payload?.bot) {
        errorSpan.textContent = "Unable to load chatbot configuration.";
        setChatEnabled(false, "Chat unavailable");
        return;
      }

      if (urlBotId !== requestedBotId) {
        window.history.replaceState(null, "", `/${encodeURIComponent(requestedBotId)}`);
      }

      instructionsText = payload.instructions || "";
      knowledgeBaseText = payload.knowledgeBase || "";
      applyBotConfig(payload.bot);
      errorSpan.textContent = "";
      setChatEnabled(true);
    }

    // --- UI HELPER FUNCTIONS ---
    
    function escapeHtml(text) {
      return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function applyInlineFormatting(text) {
      const cleaned = text
        .replace(/<br\s*\/?>/gi, " ")
        .replace(/\u00a0|&nbsp;/gi, " ")
        .replace(/\s{2,}/g, " ");
      const escaped = escapeHtml(cleaned);
      const bolded = escaped.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
      const italicized = bolded.replace(/\*([^*]+)\*/g, "<em>$1</em>");
      const emphasized = italicized.replace(/_(.*?)_/g, "<em>$1</em>");
      return emphasized.replace(/\*/g, "");
    }

    function renderTable(lines, startIndex) {
      const rows = [];
      let i = startIndex;
      while (i < lines.length && lines[i].trim().startsWith("|")) {
        const row = lines[i]
          .trim()
          .replace(/^\||\|$/g, "")
          .split("|")
          .map((cell) => applyInlineFormatting(cell.trim()));
        rows.push(row);
        i++;
      }

      let header = [];
      let body = rows;

      if (rows.length > 1 && rows[1].every((cell) => /^-+$/.test(cell.replace(/<.*?>/g, "")))) {
        header = rows[0];
        body = rows.slice(2);
      }

      const headerHtml = header.length
        ? `<thead><tr>${header.map((cell) => `<th>${cell}</th>`).join("")}</tr></thead>`
        : "";
      const bodyHtml = body
        .map((row) => `<tr>${row.map((cell) => `<td>${cell}</td>`).join("")}</tr>`)
        .join("");

      return { html: `<table class="rich-text-table">${headerHtml}<tbody>${bodyHtml}</tbody></table>`, nextIndex: i - 1 };
    }

    function formatMessage(content) {
      const lines = content.trim().split("\n");
      let html = '<div class="rich-text space-y-2">';
      let inUl = false;
      let inOl = false;

      const closeLists = () => {
        if (inUl) {
          html += "</ul>";
          inUl = false;
        }
        if (inOl) {
          html += "</ol>";
          inOl = false;
        }
      };

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) {
          closeLists();
          continue;
        }

        // Tables
        if (line.startsWith("|")) {
          closeLists();
          const { html: tableHtml, nextIndex } = renderTable(lines, i);
          html += tableHtml;
          i = nextIndex;
          continue;
        }

        // Headings
        if (/^#{1,6}\s+/.test(line)) {
          closeLists();
          const level = line.match(/^#+/)[0].length;
          const text = applyInlineFormatting(line.replace(/^#{1,6}\s+/, ""));
          html += `<h${Math.min(level + 1, 4)}>${text}</h${Math.min(level + 1, 4)}>`;
          continue;
        }

        // Divider
        if (/^(-\s*){3,}$/.test(line)) {
          closeLists();
          html += "<hr/>";
          continue;
        }

        // Ordered List
        const orderedMatch = line.match(/^\d+\.\s+(.*)/);
        if (orderedMatch) {
          if (!inOl) {
            closeLists();
            inOl = true;
            html += '<ol class="pl-4">';
          }
          html += `<li>${applyInlineFormatting(orderedMatch[1])}</li>`;
          continue;
        }

        // Unordered List
        const unorderedMatch = line.match(/^[-*]\s+(.*)/);
        if (unorderedMatch) {
          if (!inUl) {
            closeLists();
            inUl = true;
            html += '<ul class="pl-4">';
          }
          html += `<li>${applyInlineFormatting(unorderedMatch[1])}</li>`;
          continue;
        }

        // Paragraph / Card block
        closeLists();
        const paragraph = applyInlineFormatting(line);
        const isEmphasized = paragraph.startsWith("<strong>") || paragraph.toLowerCase().startsWith("note:");
        html += `<div class="${isEmphasized ? "card-block" : ""}"><p>${paragraph}</p></div>`;
      }

      closeLists();
      html += "</div>";
      return html;
    }

    function setToggleState(button, isActive) {
      button.setAttribute("aria-pressed", isActive);
      const highlightClasses = [
        "ring-4",
        "ring-offset-2",
        "ring-offset-white",
        "ring-[var(--color-secondary)]",
        "border-[var(--color-secondary)]",
        "bg-[var(--color-secondary)]/20",
        "shadow-lg",
        "shadow-yellow-200/80",
      ];

      highlightClasses.forEach((cls) => button.classList.toggle(cls, isActive));
    }

    function collectChatEntries() {
      const entries = [];
      chatLog.querySelectorAll(".msg-user, .msg-bot").forEach((node) => {
        const role = node.classList.contains("msg-user") ? "You" : botShortName;
        const contentNode = node.classList.contains("msg-user")
          ? node
          : node.querySelector("[data-role='bot-content']");
        const content = contentNode?.innerHTML.trim() || "";
        if (content) {
          entries.push({ role, content });
        }
      });
      return entries;
    }

    function downloadChat() {
      const entries = collectChatEntries();
      if (!entries.length) {
        errorSpan.textContent = "No chat to download yet.";
        return;
      }
      errorSpan.textContent = "";
      window.print();
    }

    function updatePendingFocusInstruction() {
      const { clinical, sports } = focusState;
      if (clinical && sports) {
        pendingFocusInstruction = "use examples specific to sports related clinical exercise physiology";
      } else if (clinical) {
        pendingFocusInstruction = "use an example appropriate to clinical exercise physiology that is not sports related";
      } else if (sports) {
        pendingFocusInstruction = "use an example appropriate to sports that is not clinical exercise physiology related";
      } else {
        pendingFocusInstruction = "";
      }
    }

    function addUserMessage(content, attachmentName) {
        const attachmentHtml = attachmentName
          ? `
            <div class="mt-2 inline-flex items-center gap-1 rounded-full bg-white/70 px-2 py-1 text-[11px] text-slate-700">
              <i data-lucide="file-text" class="w-3.5 h-3.5"></i>
              <span>${escapeHtml(attachmentName)}</span>
            </div>
          `
          : "";
        const div = document.createElement("div");
        div.className = "flex gap-4 flex-row-reverse animate-[fadeIn_0.3s_ease-out]";
        div.innerHTML = `
            <div class="space-y-1 max-w-[85%]">
                <div class="msg-user bg-[var(--color-secondary)] text-black p-4 text-sm leading-relaxed shadow-lg">
                    ${formatMessage(content)}
                    ${attachmentHtml}
                </div>
                <div class="mt-2 flex items-center justify-end gap-2 text-xs text-slate-600">
                  <button type="button" class="copy-button inline-flex h-8 w-8 items-center justify-center rounded-full shadow-sm" data-role="copy-button" aria-label="Copy message text" title="Copy text">
                    <i data-lucide="copy" class="w-4 h-4"></i>
                  </button>
                  <span>Copy</span>
                </div>
            </div>
        `;
        chatLog.appendChild(div);
        const contentEl = div.querySelector(".msg-user");
        const copyButton = div.querySelector("[data-role='copy-button']");
        wireCopyButton(copyButton, contentEl);
        chatLog.scrollTop = chatLog.scrollHeight;
        lucide.createIcons();
    }

    function scrollMessageToTop(element) {
        const containerRect = chatLog.getBoundingClientRect();
        const elementRect = element.getBoundingClientRect();
        const offset = elementRect.top - containerRect.top + chatLog.scrollTop;
        chatLog.scrollTo({ top: offset, behavior: "smooth" });
    }

    function addBotMessage(content) {
        const profileUrl = escapeAttribute(botProfileImageUrl);
        const fallbackUrl = escapeAttribute(botFallbackAvatarUrl);
        const altText = escapeAttribute(botDisplayName);
        const nameLabel = escapeHtml(botShortName);
        const div = document.createElement("div");
        div.className = "flex gap-4 animate-[slideIn_0.3s_ease-out]";
        div.innerHTML = `
             <img src="${profileUrl}"
                  data-fallback="${fallbackUrl}"
                  class="w-10 h-10 rounded-full object-cover border border-slate-200 flex-none self-end mb-1"
                  alt="${altText}"
                  onerror="if (this.dataset.fallback) { this.src = this.dataset.fallback; }">
            <div class="space-y-1 max-w-[85%]">
                <div class="text-xs text-slate-500 ml-1">${nameLabel}</div>
                <div class="flex items-start gap-2">
                  <div class="msg-bot bg-white border border-slate-200 p-4 text-sm leading-relaxed shadow-sm text-slate-800">
                      <div data-role="bot-content">${formatMessage(content)}</div>
                      <div data-role="followup-container" class="mt-3 flex flex-wrap gap-2 hidden"></div>
                  </div>
                  <button
                    type="button"
                    class="tts-button h-9 w-9 rounded-full flex items-center justify-center shadow-sm"
                    data-role="tts-button"
                    data-state="idle"
                    aria-label="Play message audio"
                    title="Play audio"
                    disabled>
                    <i data-lucide="volume-2" class="w-4 h-4"></i>
                  </button>
                </div>
                <div class="mt-2 flex items-center gap-2 text-xs text-slate-500">
                  <button type="button" class="copy-button inline-flex h-8 w-8 items-center justify-center rounded-full shadow-sm" data-role="copy-button" aria-label="Copy message text" title="Copy text">
                    <i data-lucide="copy" class="w-4 h-4"></i>
                  </button>
                  <span>Copy</span>
                </div>
            </div>
        `;
        chatLog.appendChild(div);
        const contentEl = div.querySelector("[data-role='bot-content']");
        const ttsButton = div.querySelector("[data-role='tts-button']");
        const copyButton = div.querySelector("[data-role='copy-button']");
        const followupContainer = div.querySelector("[data-role='followup-container']");
        ttsButton.addEventListener("click", () => handleTtsButtonClick(ttsButton));
        wireCopyButton(copyButton, contentEl);
        lucide.createIcons();
        scrollMessageToTop(contentEl);
        return { contentEl, ttsButton, followupContainer };
    }

    function setCopyButtonState(button, state) {
      button.dataset.state = state;
      if (state === "copied") {
        button.setAttribute("aria-label", "Copied message text");
        button.setAttribute("title", "Copied");
        button.innerHTML = '<i data-lucide="check" class="w-4 h-4"></i>';
      } else {
        button.setAttribute("aria-label", "Copy message text");
        button.setAttribute("title", "Copy text");
        button.innerHTML = '<i data-lucide="copy" class="w-4 h-4"></i>';
      }
      lucide.createIcons();
    }

    async function copyMessageContent(contentEl, button) {
      if (!contentEl || !button) return;
      const selection = window.getSelection();
      if (selection) {
        selection.removeAllRanges();
        const range = document.createRange();
        range.selectNodeContents(contentEl);
        selection.addRange(range);
      }
      const text = contentEl.innerText.trim();
      try {
        await navigator.clipboard.writeText(text);
      } catch (error) {
        try {
          document.execCommand("copy");
        } catch (fallbackError) {
          console.error("Copy failed", fallbackError);
        }
      }
      setCopyButtonState(button, "copied");
      setTimeout(() => setCopyButtonState(button, "idle"), 2000);
    }

    function wireCopyButton(button, contentEl) {
      if (!button || !contentEl) return;
      button.addEventListener("click", () => copyMessageContent(contentEl, button));
    }

    const initialCopyButton = chatLog.querySelector("[data-role='copy-button']");
    const initialContent = chatLog.querySelector("[data-role='bot-content']");
    if (initialCopyButton && initialContent) {
      setCopyButtonState(initialCopyButton, "idle");
      wireCopyButton(initialCopyButton, initialContent);
    }

    function setTtsButtonState(button, state) {
      button.dataset.state = state;
      if (state === "loading") {
        button.setAttribute("aria-label", "Stop message audio");
        button.setAttribute("title", "Stop audio");
      } else {
        button.setAttribute("aria-label", "Play message audio");
        button.setAttribute("title", "Play audio");
      }
    }

    function setTtsButtonText(button, text) {
      button.dataset.ttsText = text;
      button.disabled = !text;
    }

    function clearTtsHighlights(container) {
      if (!container) return;
      const highlights = container.querySelectorAll(".tts-highlight");
      highlights.forEach((highlight) => {
        const textNode = document.createTextNode(highlight.textContent || "");
        highlight.replaceWith(textNode);
      });
      container.normalize();
    }

    function getTextNodesWithOffsets(container) {
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
      const nodes = [];
      let index = 0;
      let node;
      while ((node = walker.nextNode())) {
        const value = node.nodeValue || "";
        const length = value.length;
        if (length) {
          nodes.push({ node, start: index, end: index + length });
          index += length;
        }
      }
      return nodes;
    }

    function getContainerText(container) {
      if (!container) return "";
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
      let text = "";
      let node;
      while ((node = walker.nextNode())) {
        text += node.nodeValue || "";
      }
      return text;
    }

    function highlightTextRange(container, start, end) {
      if (!container) return;
      clearTtsHighlights(container);
      if (start >= end) return;
      const nodes = getTextNodesWithOffsets(container);
      nodes.forEach(({ node, start: nodeStart, end: nodeEnd }) => {
        if (nodeEnd <= start || nodeStart >= end) return;
        let workingNode = node;
        const startOffset = Math.max(start - nodeStart, 0);
        const endOffset = Math.min(end - nodeStart, workingNode.nodeValue.length);
        if (endOffset < workingNode.nodeValue.length) {
          workingNode.splitText(endOffset);
        }
        if (startOffset > 0) {
          workingNode = workingNode.splitText(startOffset);
        }
        const highlightSpan = document.createElement("span");
        highlightSpan.className = "tts-highlight";
        highlightSpan.textContent = workingNode.nodeValue;
        workingNode.replaceWith(highlightSpan);
      });
    }

    function splitIntoSentences(text) {
      const sentences = [];
      if (!text) return sentences;
      const regex = /[^.!?;:]+[.!?;:]+(?:["'”’]+)?|[^.!?;:]+$/g;
      let match;
      let offset = 0;
      while ((match = regex.exec(text)) !== null) {
        const chunk = match[0];
        const trimmed = chunk.trim();
        if (!trimmed) {
          offset += chunk.length;
          continue;
        }
        const leadingWhitespace = chunk.indexOf(trimmed);
        const start = offset + leadingWhitespace;
        const end = start + trimmed.length;
        sentences.push({ text: trimmed, start, end });
        offset += chunk.length;
      }
      return sentences;
    }

    function stopActiveAudio({ resumeMic = true } = {}) {
      ttsPlaybackToken += 1;
      if (activeAudio) {
        activeAudio.pause();
        activeAudio.currentTime = 0;
      }
      if (activeUtterance && "speechSynthesis" in window) {
        window.speechSynthesis.cancel();
      }
      if (activeTtsButton) {
        setTtsButtonState(activeTtsButton, "idle");
      }
      if (activeTtsContentEl) {
        clearTtsHighlights(activeTtsContentEl);
      }
      activeAudio = null;
      activeTtsButton = null;
      activeUtterance = null;
      activeTtsContentEl = null;
      if (resumeMic) {
        resumeRecognitionAfterTts();
      }
    }

    function detectLanguageTag(text) {
      const sample = text.slice(0, 500);
      if (/[\u4e00-\u9fff]/.test(sample)) return "zh";
      if (/[\u3040-\u30ff]/.test(sample)) return "ja";
      if (/[\uac00-\ud7af]/.test(sample)) return "ko";
      if (/[\u0400-\u04ff]/.test(sample)) return "ru";
      if (/[\u0600-\u06ff]/.test(sample)) return "ar";
      if (/[\u0900-\u097f]/.test(sample)) return "hi";
      if (/[\u0590-\u05ff]/.test(sample)) return "he";
      if (/[\u0e00-\u0e7f]/.test(sample)) return "th";
      if (/[¿¡ñáéíóúü]/i.test(sample)) return "es";
      if (/[àâçéèêëîïôùûüÿœ]/i.test(sample)) return "fr";
      return "en";
    }

    function refreshVoices() {
      if (!("speechSynthesis" in window)) return;
      availableVoices = window.speechSynthesis.getVoices() || [];
    }

    function selectSpeechSynthesisVoice(lang) {
      if (!availableVoices.length) refreshVoices();
      const normalized = lang.toLowerCase();
      return (
        availableVoices.find((voice) => voice.lang?.toLowerCase().startsWith(normalized)) ||
        availableVoices.find((voice) => voice.lang?.toLowerCase().startsWith(normalized.split("-")[0])) ||
        null
      );
    }

    async function playBrowserSpeech(text, lang, button, contentEl) {
      if (!("speechSynthesis" in window)) {
        throw new Error("Speech synthesis is not available.");
      }
      pauseRecognitionForTts();
      stopActiveAudio({ resumeMic: false });
      const playbackToken = ttsPlaybackToken;
      setTtsButtonState(button, "loading");
      const sentences = splitIntoSentences(text);
      if (!sentences.length) {
        setTtsButtonState(button, "idle");
        resumeRecognitionAfterTts();
        return;
      }
      activeTtsButton = button;
      activeTtsContentEl = contentEl || null;
      try {
        return await new Promise((resolve, reject) => {
          let index = 0;
          const speakNext = () => {
            if (playbackToken !== ttsPlaybackToken) {
              resolve();
              return;
            }
            if (index >= sentences.length) {
              setTtsButtonState(button, "idle");
              if (activeTtsButton === button) activeTtsButton = null;
              activeUtterance = null;
              if (activeTtsContentEl) {
                clearTtsHighlights(activeTtsContentEl);
              }
              resolve();
              return;
            }
            const sentence = sentences[index];
            const utterance = new SpeechSynthesisUtterance(sentence.text);
            const voice = selectSpeechSynthesisVoice(lang);
            if (voice) utterance.voice = voice;
            utterance.lang = lang;
            utterance.rate = ttsSpeed;
            activeUtterance = utterance;
            if (activeTtsContentEl) {
              highlightTextRange(activeTtsContentEl, sentence.start, sentence.end);
            }
            utterance.onend = () => {
              if (playbackToken !== ttsPlaybackToken) {
                resolve();
                return;
              }
              index += 1;
              speakNext();
            };
            utterance.onerror = () => {
              setTtsButtonState(button, "idle");
              if (activeTtsButton === button) activeTtsButton = null;
              activeUtterance = null;
              if (activeTtsContentEl) {
                clearTtsHighlights(activeTtsContentEl);
              }
              reject(new Error("Unable to play the generated audio."));
            };
            window.speechSynthesis.speak(utterance);
          };
          window.speechSynthesis.cancel();
          speakNext();
        });
      } finally {
        resumeRecognitionAfterTts();
      }
    }

   // A simple queue to hold pre-fetched audio blobs
let audioQueue = [];

async function playTtsForText(text, button, contentEl) {
  const speechText = contentEl ? getContainerText(contentEl).trim() : text?.trim();
  if (!speechText) return;

  if (ttsEngine === "browser") {
    const lang = detectLanguageTag(speechText);
    await playBrowserSpeech(speechText, lang, button, contentEl);
    return;
  }

  pauseRecognitionForTts();
  stopActiveAudio({ resumeMic: false });
  const playbackToken = ttsPlaybackToken;
  setTtsButtonState(button, "loading");
  activeTtsButton = button;
  activeTtsContentEl = contentEl || null;
  
  const sentences = splitIntoSentences(speechText);
  audioQueue = []; // Reset queue

  try {
    for (let i = 0; i < sentences.length; i++) {
      if (playbackToken !== ttsPlaybackToken) break;
      const sentence = sentences[i];
      
      // 1. Fetch the current sentence if it's not already in the queue
      let audioBlob;
      if (audioQueue[i]) {
        audioBlob = audioQueue[i];
      } else {
        audioBlob = await fetchAudioBlob(sentence.text);
      }

      if (playbackToken !== ttsPlaybackToken) break;

      // 2. Start pre-fetching the NEXT sentence in the background (don't 'await' it)
      if (i + 1 < sentences.length) {
        fetchAudioBlob(sentences[i + 1].text).then(blob => {
          audioQueue[i + 1] = blob;
        });
      }

      // 3. Play the current audio and wait for it to finish
      await playAudioFromBlob(audioBlob, button, contentEl, sentence, playbackToken);
    }
  } catch (err) {
    console.error("TTS Queue Error:", err);
    errorSpan.textContent = "Playback error. Switching to browser speech.";
    const lang = detectLanguageTag(speechText);
    await playBrowserSpeech(speechText, lang, button, contentEl);
  } finally {
    if (playbackToken === ttsPlaybackToken) {
      setTtsButtonState(button, "idle");
      if (activeTtsContentEl) {
        clearTtsHighlights(activeTtsContentEl);
      }
      activeTtsButton = null;
      activeTtsContentEl = null;
    }
    resumeRecognitionAfterTts();
  }
}

// Helper to ONLY fetch the audio from your Netlify function
async function fetchAudioBlob(text) {
  const response = await fetch(HF_TTS_API, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text, voice: HF_TTS_VOICES[ttsVoice], speed: ttsSpeed }),
  });

  if (!response.ok) throw new Error("Fetch failed");
  return await response.blob();
}

// Helper to ONLY play the audio and handle highlighting
function playAudioFromBlob(blob, button, contentEl, sentenceMetadata, playbackToken) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(blob);
    activeAudio = globalAudioElement;

    if (playbackToken !== ttsPlaybackToken) {
      URL.revokeObjectURL(url);
      resolve();
      return;
    }

    if (contentEl && sentenceMetadata) {
      highlightTextRange(contentEl, sentenceMetadata.start, sentenceMetadata.end);
    }

    activeAudio.onended = () => {
      URL.revokeObjectURL(url);
      resolve();
    };
    activeAudio.onpause = () => {
      if (playbackToken !== ttsPlaybackToken) {
        URL.revokeObjectURL(url);
        resolve();
      }
    };
    activeAudio.onerror = (event) => {
      URL.revokeObjectURL(url);
      reject(event);
    };
    activeAudio.src = url;
    activeAudio.play().catch(reject);
  });
}

    async function handleTtsButtonClick(button) {
      const contentEl = button.closest(".space-y-1")?.querySelector("[data-role='bot-content']");
      const text = contentEl ? getContainerText(contentEl).trim() : button.dataset.ttsText?.trim();
      if (button.dataset.state === "loading") {
        autoTtsEnabled = false;
        stopActiveAudio();
        return;
      }
      if (autoTtsEnabled) {
        autoTtsEnabled = false;
        stopActiveAudio();
        return;
      }
      if (!text) return;
      autoTtsEnabled = true;
      errorSpan.textContent = "";
      if (!narrativeModeEnabled && contentEl) {
        await handleNarrativeModeRequest({ button, contentEl });
        return;
      }
      await playTtsForText(text, button, contentEl);
    }

    function setTyping(isTyping) {
      if (isTyping) {
        typingIndicator.classList.remove("hidden");
        sendBtn.disabled = true;
        sendBtn.classList.add("opacity-50", "cursor-not-allowed");
        chatLog.appendChild(typingIndicator); 
        chatLog.scrollTop = chatLog.scrollHeight;
      } else {
        typingIndicator.classList.add("hidden");
        sendBtn.disabled = false;
        sendBtn.classList.remove("opacity-50", "cursor-not-allowed");
      }
    }

    // --- LOGIC RESTORATION ---

    function initMessages() {
      const systemPrompt = buildSystemPrompt();
      if (!systemPrompt) {
        errorSpan.textContent = "Bot instructions are missing.";
        return;
      }
      messages = [
        {
          role: "system",
          content: systemPrompt,
        },
      ];
    }

    function updateSpeechOptionsUI() {
      if (speechSpeedSelect) {
        speechSpeedSelect.value = `${ttsSpeed}`;
      }
      if (speechEngineSelect) {
        speechEngineSelect.value = ttsEngine;
      }
      speechVoiceInputs.forEach((input) => {
        input.checked = input.value === ttsVoice;
        input.disabled = ttsEngine !== "huggingface";
      });
    }

    function truncateFileName(name, maxLength = 22) {
      if (!name) return "";
      if (name.length <= maxLength) return name;
      const extIndex = name.lastIndexOf(".");
      const ext = extIndex > -1 ? name.slice(extIndex) : "";
      const base = name.slice(0, maxLength - ext.length - 1);
      return `${base}…${ext}`;
    }

    function getSessionId() {
      const storageKey = "chat_session_id";
      const existing = localStorage.getItem(storageKey);
      if (existing) return existing;
      const generated =
        (window.crypto?.randomUUID && window.crypto.randomUUID()) ||
        `session_${Date.now()}_${Math.random().toString(16).slice(2)}`;
      localStorage.setItem(storageKey, generated);
      return generated;
    }

    async function logToFirebase(role, content) {
      try {
        await fetch("/.netlify/functions/log-chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            userId: getSessionId(),
            role,
            content,
            timestamp: new Date().toISOString(),
          }),
        });
      } catch (err) {
        console.error("Failed to log to Firebase", err);
      }
    }

    function resetPdfAttachment() {
      pdfAttachment = null;
      if (pdfInput) {
        pdfInput.value = "";
      }
      if (pdfLabel) {
        pdfLabel.textContent = "PDF";
        pdfLabel.title = "";
      }
      if (pdfClearBtn) {
        pdfClearBtn.classList.add("hidden");
      }
    }

    function setPdfAttachment(file, dataUrl) {
      pdfAttachment = {
        name: file.name,
        dataUrl,
      };
      if (pdfLabel) {
        pdfLabel.textContent = truncateFileName(file.name);
        pdfLabel.title = file.name;
      }
      if (pdfClearBtn) {
        pdfClearBtn.classList.remove("hidden");
      }
    }
    
    async function bootChatbot() {
      await initializeBot();
      if (!botConfig) return;
      initMessages();
    }

    // Initialise on load
    bootChatbot();

    // Set initial toggle appearance
    setToggleState(clinicalToggle, focusState.clinical);
    setToggleState(sportsToggle, focusState.sports);

    // Focus toggle interactions
    clinicalToggle.addEventListener("click", () => {
      focusState.clinical = !focusState.clinical;
      setToggleState(clinicalToggle, focusState.clinical);
      updatePendingFocusInstruction();
    });

    sportsToggle.addEventListener("click", () => {
      focusState.sports = !focusState.sports;
      setToggleState(sportsToggle, focusState.sports);
      updatePendingFocusInstruction();
    });

    // Crisis detection
    function looksLikeCrisis(text) {
      const lowered = text.toLowerCase();
      const keywords = ["kill myself", "suicide", "want to die", "end my life", "self harm", "self-harm", "hurt myself"];
      return keywords.some((k) => lowered.includes(k));
    }

    function crisisResponse() {
      return `I'm really glad you reached out — your safety is the most important thing.
      <br><br>
      I can't provide crisis counselling, but please consider these options right now:
      <br>• If you are in immediate danger call <strong>000</strong> (Australia).
      <br>• Contact <strong>Lifeline</strong> on <strong>13 11 14</strong>.
      <br>• If you are a student, please contact your university's student wellbeing team.
      <br><br>You do not have to go through this alone.`;
    }

    function normalizeFollowupText(text) {
      return text.trim().toLowerCase();
    }

    function getVisibleAssistantContent(rawText) {
      const startToken = "<<<FOLLOWUPS>>>";
      const endToken = "<<<END_FOLLOWUPS>>>";
      const startIndex = rawText.indexOf(startToken);
      const endIndex = rawText.indexOf(endToken);
      let cutIndex = -1;

      if (startIndex !== -1 && endIndex !== -1) {
        cutIndex = Math.min(startIndex, endIndex);
      } else if (startIndex !== -1) {
        cutIndex = startIndex;
      } else if (endIndex !== -1) {
        cutIndex = endIndex;
      }

      if (cutIndex === -1) {
        return rawText;
      }
      return rawText.slice(0, cutIndex).trimEnd();
    }

    function extractFollowupsFromContent(rawText) {
      const startToken = "<<<FOLLOWUPS>>>";
      const endToken = "<<<END_FOLLOWUPS>>>";
      const startIndex = rawText.indexOf(startToken);
      if (startIndex === -1) {
        const endIndex = rawText.indexOf(endToken);
        if (endIndex !== -1) {
          return { mainText: rawText.slice(0, endIndex).trim(), followups: [] };
        }
        return { mainText: rawText.trim(), followups: [] };
      }
      const endIndex = rawText.indexOf(endToken, startIndex + startToken.length);
      if (endIndex === -1) {
        return { mainText: rawText.slice(0, startIndex).trim(), followups: [] };
      }
      const jsonBlock = rawText
        .slice(startIndex + startToken.length, endIndex)
        .trim()
        .replace(/^```(?:json)?/i, "")
        .replace(/```$/i, "")
        .trim();
      let parsed = [];
      try {
        parsed = JSON.parse(jsonBlock);
      } catch (err) {
        parsed = [];
      }
      const mainText = rawText.slice(0, startIndex).trim();
      return { mainText, followups: Array.isArray(parsed) ? parsed : [] };
    }

    async function streamAssistantResponseInto({
      messagesToSend,
      contentEl,
      ttsButton,
      expectFollowups = true,
      renderWhileStreaming = true,
    }) {
      const decoder = new TextDecoder();
      let assistantContent = "";
      let buffer = "";
      let streamEnded = false;

      const includesFile = messagesToSend.some(
        (message) =>
          Array.isArray(message.content) &&
          message.content.some((part) => part?.type === "file")
      );
      const requestBody = {
        messages: messagesToSend,
        stream: true,
      };
      if (includesFile) {
        requestBody.plugins = [
          {
            id: "file-parser",
            pdf: {
              engine: "pdf-text",
            },
          },
        ];
      }

      const response = await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const rawText = await response.text();
        let backendMsg = "The server returned an error.";
        try {
          const parsed = JSON.parse(rawText);
          if (parsed?.error) {
            backendMsg =
              typeof parsed.error === "string"
                ? parsed.error
                : parsed.error.message || backendMsg;
          }
        } catch (e) {
          // ignore
        }
        errorSpan.textContent = "Error: " + backendMsg;
        const fallbackText = "Sorry, I couldn't generate a response just now.";
        contentEl.innerHTML = formatMessage(fallbackText);
        setTtsButtonText(ttsButton, fallbackText);
        return { assistantText: fallbackText, followups: [] };
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error("Readable stream not available");
      }

      while (!streamEnded) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });

        while (true) {
          const lineEnd = buffer.indexOf("\n");
          if (lineEnd === -1) break;

          const line = buffer.slice(0, lineEnd).trim();
          buffer = buffer.slice(lineEnd + 1);

          if (!line || line.startsWith(":")) continue;
          if (!line.startsWith("data: ")) continue;

          const dataStr = line.slice(6);
          if (dataStr === "[DONE]") {
            streamEnded = true;
            break;
          }

          try {
            const parsed = JSON.parse(dataStr);

            if (parsed?.error) {
              const msg =
                parsed.error?.message || "An error occurred during streaming.";
              errorSpan.textContent = "Error: " + msg;
              streamEnded = true;
              break;
            }

            const delta = parsed?.choices?.[0]?.delta?.content || "";
            if (delta) {
              assistantContent += delta;
              if (renderWhileStreaming) {
                const visibleContent = expectFollowups
                  ? getVisibleAssistantContent(assistantContent)
                  : assistantContent;
                contentEl.innerHTML = formatMessage(visibleContent);
              }
            }

            const finishReason = parsed?.choices?.[0]?.finish_reason;
            if (finishReason === "stop" || finishReason === "length") {
              streamEnded = true;
              break;
            }
          } catch (err) {
            // Ignore malformed SSE payloads
          }
        }
      }

      const { mainText, followups } = expectFollowups
        ? extractFollowupsFromContent(assistantContent)
        : { mainText: assistantContent.trim(), followups: [] };
      if (mainText) {
        contentEl.innerHTML = formatMessage(mainText);
        setTtsButtonText(ttsButton, mainText);
      }
      return { assistantText: mainText, followups };
    }

    async function streamAssistantResponse() {
      const { contentEl: botContentEl, ttsButton, followupContainer } = addBotMessage("");
      ttsButton.dataset.userPrompt = lastUserPrompt;
      const { assistantText, followups } = await streamAssistantResponseInto({
        messagesToSend: messages,
        contentEl: botContentEl,
        ttsButton,
      });
      if (assistantText && autoTtsEnabled) {
        await playTtsForText(assistantText, ttsButton, botContentEl);
      }
      return { assistantReply: assistantText, followups, followupContainer };
    }

    function clearFollowupSuggestions() {
      document.querySelectorAll("[data-role='followup-container']").forEach((container) => {
        container.innerHTML = "";
        container.classList.add("hidden");
      });
    }

    function extractQuizFromContent(rawText) {
      const startToken = "<<<QUIZ>>>";
      const endToken = "<<<END_QUIZ>>>";
      let jsonBlock = rawText.trim();
      const startIndex = rawText.indexOf(startToken);
      if (startIndex !== -1) {
        const endIndex = rawText.indexOf(endToken, startIndex + startToken.length);
        if (endIndex === -1) return null;
        jsonBlock = rawText
          .slice(startIndex + startToken.length, endIndex)
          .trim()
          .replace(/^```(?:json)?/i, "")
          .replace(/```$/i, "")
          .trim();
      }
      try {
        const parsed = JSON.parse(jsonBlock);
        const question = parsed?.question?.trim();
        const options = Array.isArray(parsed?.options) ? parsed.options : [];
        if (!question || !options.length) return null;
        return { question, options };
      } catch (err) {
        return null;
      }
    }

    function normalizeQuizOptions(options) {
      const labels = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
      return options
        .map((option, index) => {
          if (typeof option === "string") {
            return { label: labels[index] || `${index + 1}`, text: option };
          }
          const label = (option?.label || labels[index] || `${index + 1}`).toString().trim();
          const text = (option?.text || option?.option || option?.answer || "").toString().trim();
          if (!text) return null;
          return { label, text };
        })
        .filter(Boolean);
    }

    function formatQuizForHistory(quiz) {
      const optionText = quiz.options
        .map((option) => `${option.label}) ${option.text}`)
        .join("\n");
      return `${quiz.question}\n\n${optionText}`;
    }

    function renderQuizQuestion({ contentEl, ttsButton, quiz }) {
      contentEl.innerHTML = formatMessage(quiz.question);
      setTtsButtonText(ttsButton, quiz.question);
      const optionsContainer = document.createElement("div");
      optionsContainer.className = "mt-3 flex flex-wrap gap-2";
      quiz.options.forEach((option) => {
        const button = document.createElement("button");
        button.type = "button";
        button.className =
          "followup-button inline-flex items-center gap-2 rounded-full bg-[#0052C4] px-3 py-2 text-xs font-semibold text-white shadow-sm transition-colors hover:bg-[#1a73e8]";
        button.textContent = `${option.label}. ${option.text}`;
        button.addEventListener("click", () => {
          const optionList = quiz.options
            .map((item) => `${item.label}) ${item.text}`)
            .join("\n");
          const answerPrompt = `Quiz question:\n${quiz.question}\n\nOptions:\n${optionList}\n\nSelected answer: ${option.label}) ${option.text}\n\nTell me if this is correct and explain why.`;
          handleUserMessage(answerPrompt);
        });
        optionsContainer.appendChild(button);
      });
      contentEl.appendChild(optionsContainer);
    }

    function exitTutorMode() {
      if (!tutorModeEnabled) return;
      tutorModeEnabled = false;
      clearFollowupSuggestions();
      messages.push({ role: "system", content: tutorModeExitInstruction });
      handleUserMessage(tutorModeExitPrompt);
    }

    function startTutorMode() {
      if (tutorModeEnabled) return;
      tutorModeEnabled = true;
      messages.push({ role: "system", content: tutorModeSystemInstruction });
      const kickoffPrompt =
        "Start the Socratic tutoring now based on the topic we are discussing.";
      handleUserMessage(kickoffPrompt);
    }

    async function requestQuizFromModel() {
      clearFollowupSuggestions();
      const quizPrompt = `Create a multiple-choice question based on our conversation so far.
Return ONLY JSON between the markers exactly as shown:
<<<QUIZ>>>
{"question":"...","options":[{"label":"A","text":"..."},{"label":"B","text":"..."},{"label":"C","text":"..."},{"label":"D","text":"..."}]}
<<<END_QUIZ>>>
Do not include the correct answer or any extra text.`;
      const { contentEl, ttsButton } = addBotMessage("Generating a quiz...");
      setTyping(true);
      awaitingResponse = true;
      if (speechMode === SpeechMode.CONTINUOUS) {
        pauseRecognitionForResponse();
      }

      try {
        const quizMessages = [...messages, { role: "user", content: quizPrompt }];
        const { assistantText } = await streamAssistantResponseInto({
          messagesToSend: quizMessages,
          contentEl,
          ttsButton,
          expectFollowups: false,
          renderWhileStreaming: false,
        });
        const parsed = extractQuizFromContent(assistantText || "");
        const normalizedOptions = parsed ? normalizeQuizOptions(parsed.options) : [];
        if (!parsed || !normalizedOptions.length) {
          const fallbackText =
            "Sorry, I couldn't generate a quiz just now. Please try again.";
          contentEl.innerHTML = formatMessage(fallbackText);
          setTtsButtonText(ttsButton, fallbackText);
          return;
        }
        const quiz = { question: parsed.question, options: normalizedOptions };
        renderQuizQuestion({ contentEl, ttsButton, quiz });
        messages.push({ role: "user", content: quizPrompt });
        const historyText = formatQuizForHistory(quiz);
        messages.push({ role: "assistant", content: historyText });
        logToFirebase("assistant", historyText);
      } catch (err) {
        console.error(err);
        errorSpan.textContent = "Network error connecting to backend.";
      } finally {
        awaitingResponse = false;
        setTyping(false);
        if (speechMode === SpeechMode.PUSH_TO_TALK) {
          stopListening();
        } else if (speechMode === SpeechMode.CONTINUOUS) {
          resumeRecognitionAfterResponse();
        }
      }
    }

    function renderFollowupSuggestions(container, suggestions) {
      clearFollowupSuggestions();
      if (!container) return;
      if (tutorModeEnabled) {
        const exitButton = document.createElement("button");
        exitButton.type = "button";
        exitButton.className =
          "followup-button inline-flex items-center gap-2 rounded-full bg-[#0052C4] px-3 py-2 text-xs font-semibold text-white shadow-sm transition-colors hover:bg-[#1a73e8]";
        exitButton.textContent = "Exit Tutor Mode";
        exitButton.addEventListener("click", () => {
          exitTutorMode();
        });
        container.appendChild(exitButton);
        container.classList.remove("hidden");
        return;
      }
      const fixedSuggestions = [
        {
          type: "example",
          text: "Provide an Example",
          prompt: "Provide a specific example related to your last response.",
        },
        {
          type: "quiz",
          text: "Quiz Me",
        },
        {
          type: "tutor",
          text: "Tutor Me",
        },
      ];
      fixedSuggestions.forEach((suggestion) => {
        const button = document.createElement("button");
        button.type = "button";
        button.className =
          "followup-button inline-flex items-center gap-2 rounded-full bg-[#0052C4] px-3 py-2 text-xs font-semibold text-white shadow-sm transition-colors hover:bg-[#1a73e8]";
        button.textContent = suggestion.text;
        button.addEventListener("click", () => {
          clearFollowupSuggestions();
          if (suggestion.type === "quiz") {
            requestQuizFromModel();
            return;
          }
          if (suggestion.type === "tutor") {
            startTutorMode();
            return;
          }
          handleUserMessage(suggestion.prompt);
        });
        container.appendChild(button);
      });
      container.classList.remove("hidden");
    }

    async function handleNarrativeModeRequest({ button, contentEl }) {
      if (narrativeModeInFlight) return;
      narrativeModeInFlight = true;
      const narrativeInstruction =
        "Answer all further questions in narrative style with no tables or bullet points.";
      const narrativeUserInstruction =
        "You must respond in narrative format with no tables or bullet points.";
      const placeholderText =
        "I'm just converting this response to a better format for speech - I'll be ready soon and all further responses will be done like this straight away!";
      const originalText = button.dataset.ttsText?.trim() || "";
      const priorPrompt = button.dataset.userPrompt?.trim() || lastUserPrompt.trim();
      narrativeModeEnabled = true;
      messages.push({ role: "system", content: narrativeInstruction });

      contentEl.innerHTML = formatMessage(placeholderText);
      setTtsButtonText(button, "");
      setTtsButtonState(button, "loading");

      const narrativeRequest = priorPrompt
        ? `Please rewrite your last response in narrative form. Prior prompt:\n${priorPrompt}`
        : "Please rewrite your last response in narrative form.";
      const narrativeMessages = [
        ...messages,
        {
          role: "user",
          content: `${narrativeUserInstruction}\n\n${narrativeRequest}`,
        },
      ];

      try {
        const { assistantText } = await streamAssistantResponseInto({
          messagesToSend: narrativeMessages,
          contentEl,
          ttsButton: button,
          expectFollowups: true,
        });
        if (assistantText) {
          await playTtsForText(assistantText, button, contentEl);
        } else if (originalText) {
          contentEl.innerHTML = formatMessage(originalText);
          setTtsButtonText(button, originalText);
        }
      } catch (err) {
        console.error(err);
        if (originalText) {
          contentEl.innerHTML = formatMessage(originalText);
          setTtsButtonText(button, originalText);
        }
        errorSpan.textContent = "Could not reformat the response for speech.";
      } finally {
        narrativeModeInFlight = false;
      }
    }

    // --- SPEECH HELPERS ---
    function startSilenceTimer() {
      clearTimeout(silenceTimer);
      silenceTimer = setTimeout(() => finalizeSpeechInput(), 2000);
    }

    function finalizeSpeechInput() {
      clearTimeout(silenceTimer);
      silenceTimer = null;
      if (!speechBuffer.trim()) return;
      const spokenText = speechBuffer.trim();
      speechBuffer = "";
      // Prevent auto-restart when continuous mode hits the silence boundary
      if (speechMode === SpeechMode.CONTINUOUS) {
        pausedForResponse = true;
        stopListening();
      }
      handleUserMessage(spokenText, { triggeredBySpeech: true });
    }

    function handleSpeechResult(event) {
      let added = false;
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const result = event.results[i];
        if (!result?.isFinal) continue;
        const transcript = result[0].transcript.trim();
        if (!transcript || transcript === lastFinalTranscript) continue;

        const normalizedBuffer = speechBuffer.toLowerCase();
        const normalizedTranscript = transcript.toLowerCase();
        const alreadyCaptured =
          normalizedBuffer && normalizedTranscript.startsWith(normalizedBuffer);
        const addition = alreadyCaptured
          ? transcript.slice(speechBuffer.length).trim()
          : transcript;

        if (addition) {
          speechBuffer = speechBuffer ? `${speechBuffer} ${addition}`.trim() : addition;
          added = true;
        } else if (!alreadyCaptured) {
          speechBuffer = transcript;
          added = true;
        }

        lastFinalTranscript = transcript;
      }

      if (added) {
        startSilenceTimer();
      }
    }

    function handleSpeechError(event) {
      const friendlyMessage =
        event.error === "not-allowed" || event.error === "service-not-allowed"
          ? "Microphone permission was blocked."
          : `Speech recognition error: ${event.error}`;
      errorSpan.textContent = friendlyMessage;
      speechMode = SpeechMode.OFF;
      stopListening();
      updateMicButtonUI();
    }

    function handleRecognitionEnd() {
      isListening = false;
      updateMicButtonUI();
      // Continuous mode will be resumed explicitly after the model response.
    }

    function initSpeechRecognition() {
      if (!recognitionSupported) {
        micBtn.disabled = true;
        micBtn.classList.add("opacity-50", "cursor-not-allowed");
        micModeLabel.textContent = "Speech not supported";
        return;
      }
      recognition = new RecognitionClass();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = "en-US";
      recognition.onresult = handleSpeechResult;
      recognition.onerror = handleSpeechError;
      recognition.onend = handleRecognitionEnd;
      recognition.onstart = () => {
        isListening = true;
        updateMicButtonUI();
      };
    }

    function startListening() {
      if (!recognitionSupported || !recognition || isListening || pausedForResponse || pausedForTts) return;
      speechBuffer = "";
      lastFinalTranscript = "";
      try {
        recognition.start();
        isListening = true;
      } catch (err) {
        console.error(err);
      }
      updateMicButtonUI();
    }

    function stopListening() {
      clearTimeout(silenceTimer);
      silenceTimer = null;
      speechBuffer = "";
      lastFinalTranscript = "";
      if (recognitionSupported && recognition && isListening) {
        try {
          recognition.stop();
        } catch (err) {
          console.error(err);
        }
      }
      isListening = false;
      updateMicButtonUI();
    }

    function pauseRecognitionForResponse() {
      if (!recognitionSupported) return;
      pausedForResponse = true;
      stopListening();
    }

    function resumeRecognitionAfterResponse() {
      if (!recognitionSupported) return;
      pausedForResponse = false;
      if (pausedForTts) return;
      if (speechMode === SpeechMode.CONTINUOUS) {
        startListening();
      }
    }

    function pauseRecognitionForTts() {
      if (!recognitionSupported) return;
      if (speechMode !== SpeechMode.CONTINUOUS) return;
      pausedForTts = true;
      stopListening();
    }

    function resumeRecognitionAfterTts() {
      if (!recognitionSupported) return;
      if (!pausedForTts) return;
      pausedForTts = false;
      if (speechMode === SpeechMode.CONTINUOUS && !pausedForResponse && !awaitingResponse) {
        startListening();
      }
    }

    function updateMicButtonUI() {
      const isPaused = pausedForResponse || pausedForTts;
      const icon = speechMode === SpeechMode.OFF ? "mic-off" : isPaused ? "pause-circle" : "mic";
      micBtn.innerHTML = `<i data-lucide="${icon}" class="w-5 h-5"></i>`;
      lucide.createIcons();
      micModeLabel.textContent = speechModeLabels[speechMode] || "Speech off";
      micBtn.classList.toggle("bg-[#0052C4]", speechMode !== SpeechMode.OFF && isListening);
      micBtn.classList.toggle("text-white", speechMode !== SpeechMode.OFF && isListening);
      micBtn.classList.toggle("border-[#0052C4]", speechMode !== SpeechMode.OFF && isListening);
    }

    function setSpeechMode(mode) {
      if (!recognitionSupported && mode !== SpeechMode.OFF) {
        errorSpan.textContent = "Speech recognition is not available in this browser.";
        speechMode = SpeechMode.OFF;
        stopListening();
        updateMicButtonUI();
        return;
      }
      speechMode = mode;
      speechBuffer = "";
      pausedForResponse = false;
      pausedForTts = false;
      clearTimeout(silenceTimer);
      if (speechMode === SpeechMode.OFF) {
        stopListening();
      } else {
        startListening();
      }
      updateMicButtonUI();
    }

    function cycleSpeechMode() {
      const nextMode = (speechMode + 1) % 3;
      setSpeechMode(nextMode);
    }

    // Unified user message handler (text or speech)
    async function handleUserMessage(userText, { triggeredBySpeech = false } = {}) {
      errorSpan.textContent = "";
      clearFollowupSuggestions();
      const cleanedText = userText.trim();
      const hasPdf = Boolean(pdfAttachment);
      if (!cleanedText && !hasPdf) return;
      const fallbackPrompt = cleanedText || "Please review the attached PDF.";
      lastUserPrompt = fallbackPrompt;
      const narrativeUserInstruction =
        "You must respond in narrative format with no tables or bullet points.";
      const followupInstruction =
        "Append at least one follow-up prompt after your answer exactly as specified in the system instructions.";

      const focusPrefix = pendingFocusInstruction ? `${pendingFocusInstruction}. ` : "";
      const narrativePrefix = narrativeModeEnabled ? `${narrativeUserInstruction} ` : "";
      const messageToSend = `${focusPrefix}${narrativePrefix}${fallbackPrompt}\n\n${followupInstruction}`.trim();
      pendingFocusInstruction = "";

      const userLogText = cleanedText || "PDF attached.";
      addUserMessage(userLogText, pdfAttachment?.name);
      logToFirebase("user", userLogText);
      const contentPayload = hasPdf
        ? [
            { type: "text", text: messageToSend },
            {
              type: "file",
              file: {
                filename: pdfAttachment.name,
                file_data: pdfAttachment.dataUrl,
              },
            },
          ]
        : messageToSend;
      messages.push({ role: "user", content: contentPayload }); // Update history
      if (hasPdf) {
        resetPdfAttachment();
      }

      if (!triggeredBySpeech) {
        textarea.value = "";
        textarea.style.height = 'auto'; // Reset height
      }
      
      setTyping(true);
      awaitingResponse = true;

      if (speechMode === SpeechMode.CONTINUOUS) {
        pauseRecognitionForResponse();
      }

      // Local Crisis Check
      if (looksLikeCrisis(cleanedText)) {
        setTimeout(() => {
            const supportText = crisisResponse();
            const { contentEl, ttsButton } = addBotMessage(supportText);
            setTtsButtonText(ttsButton, supportText);
            ttsButton.dataset.userPrompt = cleanedText;
            messages.push({ role: "assistant", content: supportText });
            logToFirebase("assistant", supportText);
            if (autoTtsEnabled) {
              playTtsForText(supportText, ttsButton, contentEl);
            }
            awaitingResponse = false;
            setTyping(false);
            resumeRecognitionAfterResponse();
        }, 1000); 
        return;
      }

      // Backend Call with streaming
      try {
        const { assistantReply, followups, followupContainer } = await streamAssistantResponse();
        if (assistantReply) {
          messages.push({ role: "assistant", content: assistantReply });
          logToFirebase("assistant", assistantReply);
          renderFollowupSuggestions(followupContainer, followups);
        }
      } catch (err) {
        console.error(err);
        errorSpan.textContent = "Network error connecting to backend.";
      } finally {
        awaitingResponse = false;
        setTyping(false);
        if (speechMode === SpeechMode.PUSH_TO_TALK) {
          stopListening();
        } else if (speechMode === SpeechMode.CONTINUOUS) {
          resumeRecognitionAfterResponse();
        }
      }
    }

    // Form Submission
    form.addEventListener("submit", (event) => {
      event.preventDefault();
      handleUserMessage(textarea.value);
    });

    // Handle Enter key
    textarea.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            form.dispatchEvent(new Event("submit"));
        }
    });

    pdfBtn?.addEventListener("click", () => {
      pdfInput?.click();
    });

    pdfInput?.addEventListener("change", () => {
      errorSpan.textContent = "";
      const file = pdfInput.files?.[0];
      if (!file) {
        resetPdfAttachment();
        return;
      }
      const isPdf =
        file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf");
      if (!isPdf) {
        errorSpan.textContent = "Please choose a PDF file.";
        resetPdfAttachment();
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        const result = reader.result;
        if (typeof result === "string") {
          setPdfAttachment(file, result);
        } else {
          errorSpan.textContent = "Unable to read the PDF file.";
          resetPdfAttachment();
        }
      };
      reader.onerror = () => {
        errorSpan.textContent = "Unable to read the PDF file.";
        resetPdfAttachment();
      };
      reader.readAsDataURL(file);
    });

    pdfClearBtn?.addEventListener("click", () => {
      resetPdfAttachment();
    });

    initSpeechRecognition();
    updateMicButtonUI();
    refreshVoices();
    updateSpeechOptionsUI();
    if ("speechSynthesis" in window) {
      window.speechSynthesis.onvoiceschanged = refreshVoices;
    }

    micBtn.addEventListener("click", () => {
      if (speechMode === SpeechMode.PUSH_TO_TALK && !isListening && !awaitingResponse && recognitionSupported) {
        startListening();
        return;
      }
      if (speechMode === SpeechMode.CONTINUOUS && !isListening && !awaitingResponse && recognitionSupported) {
        startListening();
        return;
      }
      cycleSpeechMode();
    });

    speechOptionsToggle?.addEventListener("click", () => {
      speechOptionsPanel?.classList.toggle("hidden");
    });

    document.addEventListener("click", (event) => {
      if (!speechOptionsPanel || !speechOptionsToggle) return;
      const target = event.target;
      if (!(target instanceof Node)) return;
      if (
        speechOptionsPanel.classList.contains("hidden") ||
        speechOptionsPanel.contains(target) ||
        speechOptionsToggle.contains(target)
      ) {
        return;
      }
      speechOptionsPanel.classList.add("hidden");
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        speechOptionsPanel?.classList.add("hidden");
      }
    });

    speechEngineSelect?.addEventListener("change", (event) => {
      const value = event.target.value;
      if (value === "huggingface" || value === "browser") {
        ttsEngine = value;
      }
      stopActiveAudio();
      updateSpeechOptionsUI();
    });

    speechSpeedSelect?.addEventListener("change", (event) => {
      const value = Number(event.target.value);
      if (ttsSpeedOptions.includes(value)) {
        ttsSpeed = value;
        if (activeUtterance) {
          activeUtterance.rate = ttsSpeed;
        }
      }
      updateSpeechOptionsUI();
    });

    speechVoiceInputs.forEach((input) => {
      input.addEventListener("change", () => {
        if (input.checked) {
          ttsVoice = input.value === "male" ? "male" : "female";
        }
        updateSpeechOptionsUI();
      });
    });

    downloadBtn?.addEventListener("click", downloadChat);
    botInfoButton?.addEventListener("click", () => {
      const message =
        botInfoMessage || "I can only answer questions based on the notes I was given.";
      alert(message);
    });

  </script>
</body>
</html>
